\documentclass[a4paper,12pt]{report}

% --------------------------------------------------
%  Packages
% --------------------------------------------------
\usepackage[utf8]{inputenc}  % Support for UTF-8 encoding
\usepackage[english]{babel}  % English language support
\usepackage{amsmath,amssymb} % Math packages
\usepackage{geometry}        % Page geometry
\usepackage{setspace}        % Line spacing
\usepackage{graphicx}        % Insert images
\usepackage{hyperref}        % Hyperlinks in the PDF
\usepackage{float}           % Improved float handling

% Page margins
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

\setstretch{1.3}  % Line spacing

% --------------------------------------------------
%  Begin Document
% --------------------------------------------------
\begin{document}

% --------------------------------------------------
%  Title Page
% --------------------------------------------------
\begin{titlepage}
    \begin{center}
        \vspace*{1.5cm}

        % AUEB Logo
        \includegraphics[width=0.9\textwidth]{./aueb_logo.png}\\[1cm]

        {\Large \textbf{Athens University of Economics and Business}}\\[0.5cm]
        {\large Department of Management Science and Technology}\\[1.5cm]

        {\Huge \textbf{Undergraduate Thesis}}\\[1.2cm]
        {\Large \textbf{Behavioral Profiling of Popular Messaging Apps Using Kernel-Level Tracing with ML Techniques}}\\[2cm]

        \textbf{Student:}\\
        Foivos - Timotheos Proestakis\\
        Student ID: 8210126\\[1.5cm]

        \textbf{Supervisors:}\\
        Prof. Diomidis Spinellis \\
        Dr. Nikolaos Alexopoulos\\[1.5cm]

        \vfill
        \textbf{Submission Date:}\\
        \today
        \vspace*{1cm}
    \end{center}
\end{titlepage}
\clearpage


% --------------------------------------------------
%  Abstract
% --------------------------------------------------
\begin{abstract}
This thesis examines kernel-level tracing techniques to create behavioral profiles of popular messaging applications using Machine Learning. The main goal is to analyze the operational characteristics of such apps and employ ML algorithms to detect patterns regarding security. The study covers topics such as kernel-level data collection, big data processing and analysis, and the design of ML models for behavior identification and classification.
\end{abstract}
\clearpage

% --------------------------------------------------
%  Acknowledgments
% --------------------------------------------------
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

I would like to express my heartfelt gratitude to my supervisors, Prof. Diomidis Spinellis and Dr. Nikolaos Alexopoulos, for their invaluable guidance, insightful feedback, and continuous support throughout the duration of this thesis. Their expertise and encouragement were instrumental in the successful completion of this work.

I would also like to sincerely thank my exceptional fellow students, Vangelis Talos and Giannis Karyotakis, for their contribution, collaboration, and for being true companions in this academic journey.

A special thanks goes to my family, whose unwavering support, both emotional and practical, made this endeavor not only possible but also deeply meaningful. Their presence and encouragement were a constant source of strength.
\clearpage

% --------------------------------------------------
%  Table of Contents
% --------------------------------------------------
\tableofcontents
\clearpage

% --------------------------------------------------
%  Introduction
% --------------------------------------------------
\chapter{Introduction}

Smartphones have become an integral component of modern society, with the number of global users surpassing 5 billion and continuing to grow rapidly \cite{statista2024smartphone}. Among the dominant mobile platforms, Android—an open-source operating system developed by Google—holds a stable global market share of approximately 75\% \cite{statista2021android}. Its open-source nature, flexibility, and widespread adoption have cultivated a vast ecosystem of applications that enhance user productivity and social interaction across various domains.

Among these applications, messaging platforms such as WhatsApp, Telegram, Facebook Messenger, and Signal have gained significant popularity, playing a central role in both personal and professional communication. However, the ubiquitous use of smartphones for such purposes has led to the accumulation of sensitive personal data on user devices, including photos, contact lists, location history, and financial information, thereby raising serious privacy and security concerns \cite{verge2018facebooksms}.

Incidents such as Facebook's unauthorized collection of SMS texts and call logs from Android devices \cite{verge2018facebooksms} underscore the vulnerabilities within existing mobile ecosystems. In response, regulatory frameworks like the General Data Protection Regulation (GDPR) and national laws such as the UK Data Protection Act 2018 aim to enforce principles of transparency, data minimization, and user consent in data processing \cite{gdpr2018, dpa2018}.

Despite these legislative efforts, Android's current permission management system remains insufficient. Users frequently misinterpret the scope and implications of the permissions they grant, inadvertently exposing sensitive data to misuse \cite{feng2020survey, felt2012permissions}.

To address these challenges, it is essential to analyze application behavior—that is, the actual operations performed by an app, both in the foreground and background. Research has shown that discrepancies often exist between user expectations and actual app behavior, with applications executing hidden or unauthorized tasks \cite{uipicker2019, gorla2014checking}. Many detection techniques rely on the assumption that user interface (UI) elements accurately represent application functionality, an assumption that is not always valid \cite{nan2019uipicker}.

Behavioral analysis methods are typically divided into static and dynamic approaches. Static analysis examines application code without execution, identifying known malicious patterns. However, it is susceptible to evasion through obfuscation and polymorphism \cite{arzt2014flowdroid, enck2010taintdroid}. In contrast, dynamic analysis evaluates applications during runtime, monitoring behaviors such as system calls, resource consumption, and network activity \cite{xu2011crowdroid, lindorfer2014andrubis}. Among these, system call analysis is particularly valuable, offering fine-grained visibility into application interactions with hardware and OS-level services \cite{canfora2015syscalls}.

Kernel-level tracing is a powerful form of dynamic analysis, capable of capturing low-level system interactions with high precision. Android is built on a modified Linux kernel that orchestrates resource management and system processes via system calls \cite{love2010linux}. Tools such as \texttt{ftrace} and \texttt{kprobes} enable developers and researchers to trace kernel-level function calls, execution flows, and resource usage \cite{rostedt2023ftrace, kernel2023kprobes}.

\texttt{Ftrace} is a built-in tracing utility within the Linux kernel, optimized for performance and capable of monitoring execution latency and function call sequences. \texttt{Kprobes}, on the other hand, allows for dynamic instrumentation of running kernels, enabling targeted probing of specific code locations during runtime \cite{corbet2015drivers}.

Applying kernel-level tracing to messaging applications, however, introduces unique technical challenges. These apps typically exhibit complex, multi-threaded behavior, frequent background processing, and diverse interactions with system resources. Accurately profiling such behavior requires collecting and interpreting high-volume, high-resolution kernel data \cite{tang2017profiling, kim2016io}.

Despite the growing research interest in Android security and behavioral analysis, existing work has primarily focused on general application profiling or malware detection. Few studies have concentrated specifically on behavioral profiling of messaging apps using kernel-level data \cite{backes2015boxify}. Meanwhile, recent reports concerning the usage of secure messaging apps such as Signal by government and military officials have emphasized the urgent need for transparent, robust behavioral analysis mechanisms \cite{washingtonpost2023signal}.

To address these gaps, this thesis proposes a structured methodology for profiling the behavior of popular messaging applications on Android through kernel-level tracing using \texttt{ftrace} and \texttt{kprobes}. The proposed approach integrates Machine Learning techniques to process and classify behavioral patterns, aiming to enhance security diagnostics, user privacy, and system transparency.

\section{Motivation and Problem Statement}
\paragraph{Motivation}
The motivation behind this research arises from the necessity to bridge existing gaps between user expectations, regulatory compliance, and the actual operational behavior of popular messaging applications. Messaging apps process extensive personal data, creating substantial risks related to privacy violations and security breaches. Recent incidents involving unauthorized data collection by prominent messaging applications, along with revelations about governmental use of supposedly secure messaging platforms, underscore significant concerns regarding transparency and user trust.

\paragraph{Problem Statement}
Current literature lacks comprehensive kernel-level behavioral analyses of messaging applications, leaving critical privacy and security risks inadequately addressed. Thus, this research seeks to systematically explore kernel-level behaviors to enhance transparency, improve user trust, and provide rigorous technical evaluations of messaging applications' privacy implications.

\section{Research Objectives}
The specific research objectives addressed in this thesis are categorized as follows:

\subsection*{Primary Objectives}
\begin{itemize}
\item Record the actual kernel-level behavior of widely used messaging applications.
\item Identify potential violations of the principle of data minimization.
\item Analyze mismatches between granted permissions and real-time resource usage.
\item Detect unauthorized or hidden access to sensitive user data.
\item Compare the behavioral profiles of privacy-focused apps (e.g., Signal) and more commercial alternatives.
\end{itemize}

\subsection*{Analytical and Technical Sub-Objectives}
\begin{itemize}
\item Develop a tracing and profiling framework using ftrace and kprobes.
\item Classify system calls into functional categories (file access, networking, IPC).
\item Monitor transitions between app states (idle, active, background).
\item Collect and analyze kernel-level usage statistics per application.
\item Identify potential indirect data leakage through side-channel patterns.
\item Correlate traced behaviors with declared permissions.
\item Implement a web-based dashboard for behavior visualization.
\end{itemize}

\subsection*{Broader Goals}
\begin{itemize}
\item Enhance transparency in how messaging apps behave at system level.
\item Improve user awareness of hidden behaviors executed in the background.
\item Demonstrate the value of kernel-level tracing for security and privacy evaluation.
\item Provide a structured and reproducible methodology for privacy-respecting behavior analysis.
\end{itemize}

\section{Research Questions}
Based on the motivation and objectives, this thesis aims to address the following research questions:

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q1.} What kernel-level operations do popular messaging applications perform during normal usage?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q2.} Are there deviations between the declared permissions of these applications and their actual behavior at runtime?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q3.} Can kernel-level tracing techniques identify unexpected or potentially invasive operations performed without user interaction?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q4.} How does the behavior of privacy-focused apps compare to that of commercial messaging platforms at the kernel level?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q5.} What kind of patterns in system calls can be used to characterize privacy-relevant behavior?
}}


\section{Limitations}
\begin{itemize}
    \item \textbf{Platform Scope}: Analysis restricted to Android 10+ due to kernel API dependencies.
    \item \textbf{Dynamic Analysis Constraints}: Real-world noise (e.g., background services) may affect system call traces.
    \item \textbf{App Selection Bias}: Focus on top-tier apps (WhatsApp, Signal, Telegram) may omit niche platforms.
\end{itemize}

\section{Contributions of this Thesis}

\section{Thesis Outline}
This thesis is organized into the following chapters:

\begin{itemize}
\item \textbf{Chapter 1 – Introduction:} Provides background context, outlines the motivation and objectives, presents the research questions, contributions, and a high-level overview of the thesis structure.
\item \textbf{Chapter 2 – Related Work and Technical Background:} Reviews existing literature on Android architecture, messaging app privacy implications, static and dynamic analysis techniques, system call tracing, and identifies key research gaps.
\item \textbf{Chapter 3 – Methodology and System Design:} Describes the research design, experimental setup, data collection using kernel-level tracing, and the analysis framework.
\item \textbf{Chapter 4 – Results:} Presents the observed behavioral patterns, differences among messaging apps, and key findings related to privacy-relevant behaviors.
\item \textbf{Chapter 5 – Discussion:} Interprets the results in light of the research questions, discusses limitations of the study, and suggests potential improvements.
\item \textbf{Chapter 6 – Conclusions:} Summarizes key contributions, highlights findings, and suggests directions for future research.
\item \textbf{Appendix A – Additional Data Tables:} Includes supplementary statistical data and traces.
\item \textbf{Appendix B – Code:} Provides relevant shell scripts, Python tools, and configuration details used in the implementation.
\end{itemize}


% --------------------------------------------------
%  Related Work and Technical Background
% --------------------------------------------------
\chapter{Related Work and Technical Background}
This thesis is part of a broader research effort investigating the security and behavioral analysis of Android applications at the kernel level. While the present work focuses on behavioral profiling for privacy analysis, other components of the research include detection mechanisms using machine learning, portability of tracing techniques across devices, and offset-agnostic instrumentation. These aspects are discussed in parallel efforts by the research team, but are outside the scope of this thesis.

This chapter provides a detailed overview of related work and technical background necessary for understanding the methodology and objectives of this thesis. First, it presents the architecture of the Android operating system, focusing particularly on the Linux-based kernel and how applications interact with it. Next, it discusses the behavior and privacy concerns related to messaging applications, highlighting known issues and relevant technical aspects. Furthermore, it outlines the advantages and limitations of static and dynamic analysis techniques and explores the role of system calls in behavior profiling. Finally, it reviews kernel-level tracing tools and techniques, and identifies gaps in existing research where this thesis contributes.
\section{Android Architecture and Kernel-Level Access}

\subsection{Android Software Stack Overview}
Android is a layered, open-source mobile operating system built on top of a customized version of the
Linux kernel. Its architecture is designed to be modular and extensible, supporting a wide range of
hardware while enforcing clear boundaries between components. The Android software stack consists
of four major layers: the Application Layer, the Java API Framework (commonly referred to as the
Application Framework), the Hardware Abstraction Layer (HAL), and the Linux Kernel.

The Application Layer hosts both system and user-installed applications.
These applications interact with the system via APIs exposed by the Android Framework.
The Java API Framework provides access to core system services such as activity management,
resource handling, content providers, and telephony. Services like \texttt{ActivityManager},
\texttt{WindowManager}, and \texttt{PackageManager} facilitate the lifecycle management and
orchestration of application behavior.

Beneath the framework lies the Android Runtime (ART), which executes application bytecode and optimizes it using ahead-of-time (AOT), just-in-time (JIT), or interpretation modes. Alongside ART are native libraries written in C/C++, including performance-critical components such as WebView, OpenSSL, and the Bionic libc. The Java Native Interface (JNI) allows managed Java/Kotlin code to call into these native libraries.

The HAL acts as a bridge between the Android Framework and the hardware drivers residing in the kernel. It defines standard interfaces that vendors implement to support various hardware components like audio, camera, sensors, and graphics. Since Android 10, Google introduced the Generic Kernel Image (GKI), which aims to further separate the vendor-specific hardware implementations from the core Linux kernel by introducing a stable kernel interface. This allows devices from different manufacturers to share a common kernel base while maintaining vendor-specific modules separately, simplifying updates and enhancing portability.

At the lowest level, the Linux kernel provides essential operating system services such as process scheduling, memory management, networking, and security enforcement. Android extends the kernel with additional features including the Binder IPC driver, ashmem (anonymous shared memory), and wakelocks to manage power usage. This kernel foundation ensures that resource access is isolated and controlled across all system layers.

\textbf{Figure 1:} Updated Diagram of Android Software Stack (source: Android Developers Guide~\cite{androidplatformdoc}).


\subsection{Application Layer and Process Lifecycle}
At the application layer, Android executes user and system applications packaged in APK format. Each APK includes compiled DEX bytecode, resources, native libraries, and a manifest file that defines app components and permissions. Apps run in sandboxed processes, each forked from the Zygote daemon—a minimal, preloaded system process that speeds up app launch time by sharing memory using copy-on-write.

The lifecycle of applications is centrally managed by the \texttt{ActivityManagerService} (AMS), which coordinates activity transitions, memory prioritization, and process states (foreground, background, cached). The \texttt{PackageManagerService} (PMS) handles component registration and permission declarations based on the manifest.

Apps follow a component-based model: Activities, Services, Broadcast Receivers, and Content Providers. These components interact with the system and one another via well-defined lifecycles and IPC through the Binder driver. Operations like binding to a service or launching an activity initiate system-level behavior—such as context switches or memory allocations—which are visible in syscall traces.

Binder IPC enables structured communication between app components and system services. Messages are serialized as Parcel objects, routed through the Binder driver, and trigger observable kernel events. These include context switches and transaction dispatches, which are measurable using tools like ftrace or kprobes.

Understanding transitions between app states (e.g., from idle to foreground) is vital in syscall-level profiling. For instance, foreground activation often leads to bursts of system calls such as \texttt{open()}, \texttt{stat()}, and \texttt{mmap()}—associated with UI initialization and resource loading. Such behaviors form recognizable patterns in kernel trace logs.
\textbf{Figure 2:} Android Application Lifecycle and Corresponding Kernel-Level Events.

\subsection{Android Runtime, Native Layer, and JNI}
The Android Runtime (ART) executes application bytecode using a combination of ahead-of-time (AOT), just-in-time (JIT), and interpretation mechanisms. From a kernel-level tracing perspective, JIT-related memory operations may trigger system calls such as \texttt{mmap()}, \texttt{write()}, and \texttt{mprotect()}, as ART dynamically allocates memory for optimized code.

Beyond execution, ART interacts with the kernel to manage thread scheduling and memory access—behaviors that appear in system call traces. In dynamic analysis, such patterns can be correlated with app lifecycle events or anomalous execution spikes.

JNI further extends the runtime by enabling Java/Kotlin code to invoke native C/C++ libraries. These native operations often bypass standard framework controls, introducing low-level file, network, or cryptographic actions. This is particularly relevant for behavioral profiling, as native code may perform sensitive operations that differ from those visible at the Java level.

In the context of this thesis, which focuses on dynamic kernel-level analysis, capturing system interactions initiated by ART and JNI is essential. It enables the identification of execution phases or modules that deviate from expected behavior—especially in apps that rely heavily on native components for messaging, encryption, or background communication.
\textbf{Figure 3:} JNI and ART Interaction with Kernel during JIT and Native Execution.

\subsection{Linux Kernel Fundamentals in Android}
The Android operating system is built upon the Linux kernel, which serves as the foundational layer responsible for resource management, hardware abstraction, and secure process isolation. In the context of behavioral profiling and kernel-level tracing, the Linux kernel plays a pivotal role, as all application interactions with hardware and system resources are mediated through kernel functions and system calls.

A defining feature of the Linux kernel is its mediation of access to CPU, memory, file systems, and networking via the system call interface. When an Android application invokes a function that requires low-level operations (e.g., file access or sensor usage), it ultimately issues a system call that transitions the execution context from user space to kernel space. This transition boundary is where most behavioral artifacts manifest, making it ideal for tracing.

Android’s kernel incorporates additional components such as the Binder IPC driver, ashmem (for shared memory), and wakelocks (for power management). These Android-specific extensions generate kernel-level events observable by tracing tools. For example, Binder transactions facilitate inter-process communication and leave traceable patterns that can reveal background behavior of messaging apps.

Security is enforced through UID-based process separation, Linux namespaces, and SELinux Mandatory Access Control policies. Each app operates in its own sandbox and is assigned a unique UID, ensuring isolation at the kernel level. Deviations from expected isolation, especially in privileged system calls, may indicate abnormal or privacy-invading behavior.

Kernel tracing tools such as ftrace and kprobes allow developers to monitor kernel execution paths. Functions like \texttt{ksys\_open}, \texttt{\_\_sys\_sendmsg}, or \texttt{\_\_schedule} can be instrumented to capture low-level events such as file access, message transmission, or task switching. These traces are then analyzed to form behavioral profiles.

\textbf{Figure 4:} User Space to Kernel Space System Call Execution Path.

\subsection{System Calls and Kernel Interaction}
System calls are the primary interface through which Android applications interact with the kernel. Every high-level operation, such as reading a file or creating a socket, is translated into one or more system calls. These calls serve as an unfiltered log of what the application is actually doing, independent of its declared permissions or advertised functions.

In Android, system calls are usually invoked via the Bionic libc or directly through JNI bindings to native code. Behavioral profiling benefits from capturing these calls in real-time to identify patterns that indicate unexpected or excessive access to system resources.

Kernel tracing frameworks like ftrace and kprobes, and to a more advanced extent eBPF, can intercept and log system calls for offline or live analysis. For instance, an app issuing \texttt{sendto()} and \texttt{connect()} calls repeatedly in the background may be exfiltrating data without user knowledge.

\textbf{Figure 5:} Categorization of System Calls for Profiling: I/O, Network, IPC, Memory.

\subsection{ Android Security Model and Isolation Mechanisms}
Android enforces a layered security model combining Linux kernel features with user-space controls. Each application runs in its own sandbox, identified by a unique UID and GID, restricting file and device access. This is complemented by the use of SELinux in enforcing mode, which uses MAC policies to define allowable interactions between system components and applications.

Filesystem isolation further ensures that apps can only access their designated directories (e.g., \texttt{/data/data/{package\_name}}). Attempts to traverse or access other app spaces are blocked unless the app has elevated privileges or exploits kernel vulnerabilities.

System call filtering through seccomp restricts the range of calls an app can make, reducing the kernel's attack surface. From a profiling standpoint, observing unauthorized system calls or failed access attempts provides insight into potentially malicious or privacy-invasive behavior.

\textbf{Figure 6:} Android Security Layers: UID Isolation, SELinux, seccomp, Filesystem Sandboxing.

\subsection*{Figures and Diagrams}
\begin{itemize}
\item Figure 1: Android Software Stack
\item Figure 2: Application Lifecycle
\item Figure 3: Kernel and User-Space Separation
\item Figure 4: Binder IPC Mechanism
\item Figure 5: SELinux and Access Control Flow
\item Figure 6: System Call Interaction Flow
\item Figure 7: Kernel Tracing Pipeline
\end{itemize}

Relevant sources and additional references include official Android documentation, Linux kernel manuals, and peer-reviewed papers on Android system architecture and security.
\section{Messaging Apps: Characteristics  Privacy Implications}


\section{Static vs. Dynamic Analysis}

\section{System Call Analysis and Kernel Tracing}

\section{Machine Learning for Behavior Profiling}

\section{Related Research  Gaps in Literature}

% --------------------------------------------------
%  Research Methodology
% --------------------------------------------------
\chapter{Methodology and System Design}

\section{Research Design}

\section{Experimental Setup}
A discussion of experimental settings, including how experiments were conducted and what evaluation metrics (e.g., accuracy, precision, recall, F1-score) were used.



\section{Data Collection and Preparation}
A detailed description of how kernel-level data is collected and the preprocessing steps taken to ensure suitability for ML algorithms.

\section{Feature Extraction from System Calls}

\section{Machine Learning Models and Tools}
An overview of the ML algorithms (e.g., Random Forest, SVM, Neural Networks) and the software tools (e.g., Python, scikit-learn) employed in the study.




% --------------------------------------------------
%  Results
% --------------------------------------------------
\chapter{Results}
\section{Behavioral Patterns Observed}

\section{Model Performance}

\section{Comparison Between Messaging Apps}

\section{Classification or Pattern Recognition Outcomes}
Presentation of evaluation tables, charts, and analysis derived from the ML algorithms.

\section{Comparisons and Interpretations}
Comparison of different models or configurations, with emphasis on interpreting discrepancies and assessing each model’s performance.

\section{ Visualizations}

% --------------------------------------------------
%  Discussion
% --------------------------------------------------
\chapter{Discussion}

\section{Interpretation of Results}

\section{Limitations of the Study}

\section{Opportunities for Improvement}


A detailed discussion of how the findings relate to the initial research objectives and the broader literature. The contribution and limitations of this study are highlighted.

% --------------------------------------------------
%  Conclusions
% --------------------------------------------------
\chapter{Conclusions}

\section{Key Findings}
A summary of the main results and how they address the initial research questions.

\section{Future Research Directions}
Suggestions for expanding this research, including improvements or new avenues for study.

% --------------------------------------------------
%  References
% --------------------------------------------------
\begin{thebibliography}{99}
    \bibitem{statista2024smartphone} Statista, \textit{Number of smartphone users worldwide from 2014 to 2029}, 2024. Available: \url{https://www.statista.com/forecasts/1143723/smartphone-users-in-the-world}

    \bibitem{statista2021android} F. Laricchia, "Mobile operating systems’ market share worldwide from January 2012 to July 2020," Statista, 2021. \url{https://www.statista.com/statistics/272698/global-market-share-held-by-mobile-operating-systems-since-2009/}

    \bibitem{verge2018facebooksms} The Verge, "Facebook has been collecting call history and SMS data from Android devices," 2018. \url{https://www.theverge.com/2018/3/25/17160944/facebook-call-history-sms-data-collection-android}

    \bibitem{gdpr2018} GDPR.EU, \textit{General Data Protection Regulation}, 2018. \url{https://gdpr.eu/}

    \bibitem{dpa2018} UK Government, \textit{Data Protection Act 2018}, \url{https://www.legislation.gov.uk/ukpga/2018/12/contents/enacted}

    \bibitem{feng2020survey} Z. Feng et al., "A Survey on Security and Privacy Issues in Android," IEEE Communications Surveys \& Tutorials, vol. 22, no. 4, pp. 2445-2472, 2020.

    \bibitem{felt2012permissions} A. Felt et al., "Android Permissions: User Attention, Comprehension, and Behavior," SOUPS, 2012.

    \bibitem{gorla2014checking} A. Gorla et al., "Checking App Behavior Against App Descriptions," ICSE, 2014.

    \bibitem{nan2019uipicker} Y. Nan et al., "UIPicker: User-Input Privacy Identification in Mobile Applications," IEEE TSE, 2019.

    \bibitem{arzt2014flowdroid} S. Arzt et al., "FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps," PLDI, 2014.

    \bibitem{enck2010taintdroid} W. Enck et al., "TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones," OSDI, 2010.

    \bibitem{xu2011crowdroid} Z. Xu et al., "Crowdroid: Behavior-Based Malware Detection System for Android," SPSM, 2011.

    \bibitem{lindorfer2014andrubis} M. Lindorfer et al., "ANDRUBIS - 1,000,000 Apps Later: A View on Current Android Malware Behaviors," BADGERS, 2014.

    \bibitem{canfora2015syscalls} G. Canfora et al., "Detecting Android Malware Using Sequences of System Calls," IEEE TSE, 2015.

    \bibitem{love2010linux} R. Love, \textit{Linux Kernel Development}, Addison-Wesley, 2010.

    \bibitem{rostedt2023ftrace} S. Rostedt, "Ftrace: Function Tracer," Linux Kernel Documentation, 2023.

    \bibitem{kernel2023kprobes} Linux Kernel Organization, "Kernel Probes (kprobes)," Linux Kernel Documentation, 2023.

    \bibitem{corbet2015drivers} J. Corbet, G. Kroah-Hartman, A. Rubini, \textit{Linux Device Drivers}, 4th ed., O'Reilly Media, 2015.

    \bibitem{tang2017profiling} J. Tang et al., "Profiling Android Applications via Kernel Tracing," IEEE TMC, 2017.

    \bibitem{kim2016io} J. Kim et al., "Understanding I/O Behavior in Android Applications through Kernel Tracing," ACM MobiSys, 2016.

    \bibitem{backes2015boxify} M. Backes et al., "Boxify: Full-fledged App Sandboxing for Stock Android," USENIX Security, 2015.

    \bibitem{washingtonpost2023signal} The Washington Post, "Pentagon officials used Signal messaging app, raising security concerns," March 2023.
    \end{thebibliography}
\clearpage

% --------------------------------------------------
%  Appendices
% --------------------------------------------------
\appendix

\chapter{Appendix A: Additional Data Tables}
Any further data tables, graphics, or supplementary material.

\chapter{Appendix B: Code}
Source code or additional scripts too extensive to include in the main chapters.

\end{document}
