\documentclass[a4paper,12pt]{report}

% --------------------------------------------------
%  Packages
% --------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% ---------------------------------------------------------
% math & layout
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{siunitx}
\usepackage{lmodern}

% ---------------------------------------------------------
% graphics, colour, hyperlinks
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{bookmark}

% ---------------------------------------------------------
% floats, algorithms, code
\usepackage{float}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{listings}
\usepackage[labelfont=bf]{caption}

% ---------------------------------------------------------
% tables & lists
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{xurl}

% ---------------------------------------------------------
% symbols for ✓ / ✗
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}} % ✓
\newcommand{\xmark}{\ding{55}} % ✗

\usepackage{acronym}

% ---------------------------------------------------------
% tikz
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,shadows.blur,shapes.geometric,fit}
% Define JSON language for listings
\lstdefinelanguage{json}{
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    literate=
     *{0}{{{\color{blue}0}}}{1}
      {1}{{{\color{blue}1}}}{1}
      {2}{{{\color{blue}2}}}{1}
      {3}{{{\color{blue}3}}}{1}
      {4}{{{\color{blue}4}}}{1}
      {5}{{{\color{blue}5}}}{1}
      {6}{{{\color{blue}6}}}{1}
      {7}{{{\color{blue}7}}}{1}
      {8}{{{\color{blue}8}}}{1}
      {9}{{{\color{blue}9}}}{1}
      {:}{{{\color{red}:}}}{1}
      {,}{{{\color{red},}}}{1}
      {"}{{{\color{orange}"}}}{1},
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    commentstyle=\color{gray},
    morecomment=[l][\color{magenta}]{//},
}

% Page margins
\geometry{margin=2.5cm, bindingoffset=0.8cm}

\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  breaklines=true,
  backgroundcolor=\color{gray!10},
  captionpos=b,
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  showstringspaces=false,
  columns=fullflexible,
  language=bash
}

\setstretch{1.3}  % Line spacing

% --------------------------------------------------
%  Begin Document
% --------------------------------------------------
\begin{document}

% --------------------------------------------------
%  Title Page
% --------------------------------------------------
\begin{titlepage}
    \begin{center}
        \vspace*{1.5cm}

        % AUEB Logo
        \includegraphics[width=0.9\textwidth]{./aueb_logo.png}\\[1cm]

        {\Large \textbf{Athens University of Economics and Business}}\\[0.5cm]
        {\large Department of Management Science and Technology}\\[1.5cm]

        {\Huge \textbf{Undergraduate Thesis}}\\[1.2cm]
        {\Large \textbf{The Kernel Never Lies: A Hybrid Security Analysis of Evasive Behaviors in Messaging Apps}}\\[2cm]
        \textbf{Student:}\\
        Foivos - Timotheos Proestakis\\
        Student ID: 8210126\\[1.5cm]

        \textbf{Supervisors:}\\
        Prof. Diomidis Spinellis \\
        Dr. Nikolaos Alexopoulos\\[1.5cm]

        \vfill
        \textbf{Submission Date:}\\
        \today
        \vspace*{1cm}
    \end{center}
\end{titlepage}
\clearpage


% --------------------------------------------------
%  Abstract
% --------------------------------------------------
\begin{abstract}
This thesis introduces a hybrid security analysis methodology for generating detailed behavioral profiles of popular mobile messaging applications by combining static inspection with custom kernel-level dynamic tracing. Specifically, the dynamic tracing extends the SliceDroid framework with a custom web dashboard, enabling visualization of kernel-level events such as system calls, IPC, and network activity.

To demonstrate its effectiveness, comprehensive static and dynamic analyses were performed on three widely used messaging apps: Signal, Telegram, and Meta Messenger. The static inspection, conducted with tools such as MobSF, APKID, and Androguard, highlighted distinct differences in manifest configurations, permission scopes, cryptographic implementations, and third-party integrations — notably, Messenger was found to request and utilize broader contact and storage permissions compared to the more privacy-restrictive Signal.

For dynamic evaluation, the extended SliceDroid collected precise runtime data under realistic usage scenarios, capturing file system operations, IPC calls and network flows. The combined analyses uncovered significant behavioral differences: Messenger exhibited the highest runtime complexity and heavy IPC usage, and notably, it was discovered that Messenger continues to access user contacts even after permission is revoked. This appears to be achieved through a persistent sync adapter state within Google Play Services, highlighting an aspect of the Android permission model that may warrant further investigation, and which was not readily apparent through static analysis alone.

Overall, these findings highlight the value of integrating static analysis with kernel-level tracing to reveal hidden operations and inform more robust security and privacy evaluations of mobile applications.
\end{abstract}

\clearpage



% --------------------------------------------------
%  Acknowledgments
% --------------------------------------------------
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

I would like to express my gratitude to Dr. Nikolaos Alexopoulos, for his invaluable guidance, insightful feedback,
and continuous support throughout the duration of this thesis. His expertise and
encouragement were instrumental in the successful completion of this work.

I would also like to sincerely thank my exceptional fellow students, Vangelis Talos
and Giannis Karyotakis, for their contribution, collaboration, and for being true companions
in this academic journey.

A special thanks goes to my family, whose unwavering support, both emotional and practical,
made this endeavor not only possible but also deeply meaningful. Their presence and
encouragement were a constant source of strength.

\vspace{1cm}
\noindent
[\today] \hfill [Foivos - Timotheos Proestakis]

\clearpage
% --------------------------------------------------
%  Table of Contents
% --------------------------------------------------

\tableofcontents
\clearpage


% ==================================================
%  List of Acronyms
% ==================================================
\chapter*{List of Acronyms}
\addcontentsline{toc}{chapter}{List of Acronyms}
\begin{acronym}[GDPR] % The longest acronym for alignment purposes
    \acro{ADB}{Android Debug Bridge}
    \acro{AMS}{ActivityManagerService}
    \acro{ANOVA}{Analysis of Variance}
    \acro{AOT}{Ahead-Of-Time}
    \acro{API}{Application Programming Interface}
    \acro{APK}{Android Package Kit}
    \acro{ART}{Android Runtime}
    \acro{DBI}{Dynamic Binary Instrumentation}
    \acro{DEX}{Dalvik Executable}
    \acro{E2EE}{End-to-End Encryption}
    \acro{eBPF}{extended Berkeley Packet Filter}
    \acro{FCM}{Firebase Cloud Messaging}
    \acro{GDPR}{General Data Protection Regulation}
    \acro{GID}{Group ID}
    \acro{GKI}{Generic Kernel Image}
    \acro{HAL}{Hardware Abstraction Layer}
    \acro{HSD}{Honestly Significant Difference}
    \acro{ICC}{Inter-Component Communication}
    \acro{IPC}{Inter-Process Communication}
    \acro{JIT}{Just-In-Time}
    \acro{JNI}{Java Native Interface}
    \acro{JSON}{JavaScript Object Notation}
    \acro{MAC}{Mandatory Access Control}
    \acro{MobSF}{Mobile Security Framework}
    \acro{NX}{Non-Executable Stack}
    \acro{OTA}{Over-The-Air}
    \acro{PIE}{Position-Independent Executable}
    \acro{PII}{Personally Identifiable Information}
    \acro{PMS}{PackageManagerService}
    \acro{PRNG}{Pseudo-Random Number Generator}
    \acro{RELRO}{Relocation Read-Only}
    \acro{SDK}{Software Development Kit}
    \acro{SELinux}{Security-Enhanced Linux}
    \acro{SQL}{Structured Query Language}
    \acro{SSL}{Secure Sockets Layer}
    \acro{TCP}{Transmission Control Protocol}
    \acro{TLS}{Transport Layer Security}
    \acro{UDP}{User Datagram Protocol}
    \acro{UID}{User ID}
    \acro{UI}{User Interface}
    \acro{WAL}{Write-Ahead Logging}
    \acro{WSL}{Windows Subsystem for Linux}
    \acro{XMPP}{Extensible Messaging and Presence Protocol}
\end{acronym}
\clearpage


% --------------------------------------------------
%  Introduction
% --------------------------------------------------
\chapter{Introduction}

Smartphones have become an integral component of modern society, with the number
of global users surpassing 5 billion and continuing to grow rapidly
\cite{DataReportal2025}. Among the dominant mobile platforms, Android—an
open-source operating system developed by Google—holds a stable global market
share of approximately 75\% \cite{StatCounter2025}. Its open-source nature,
flexibility, and widespread adoption have cultivated a vast ecosystem of
applications that enhance user productivity and social interaction across
various domains.

Among these applications, messaging platforms such as Telegram, Messenger, and Signal have gained significant popularity, playing a
central role in both personal and professional communication. However, the
ubiquitous use of smartphones for such purposes has led to the accumulation of
sensitive personal data on user devices, including photos, contact lists,
location history, and financial information, thereby raising serious privacy and
security concerns \cite{ArsTechnica2018}, \cite{ShenVervierStringhini2021}.

Incidents such as Facebook’s unauthorized collection of SMS texts and call logs
from Android devices \cite{ArsTechnica2018} underscore the vulnerabilities
within existing mobile ecosystems. In response, regulatory frameworks like the
General Data Protection Regulation (GDPR) and national laws such as the UK Data
Protection Act 2018 aim to enforce principles of transparency, data
minimization, and user consent in data processing
\cite{GDPR2016,UKDPA2018}. Despite these efforts, Android’s permission model
often fails in practice—users frequently misinterpret the scope of the
privileges they grant, inadvertently exposing sensitive data \cite{CHI2024Permissions}.

End-to-end encryption (E2EE) provides strong guarantees for content
confidentiality, yet its effectiveness ultimately depends on correct
implementation, device-level protections, and careful metadata handling
\cite{arxiv2020metadata,CohnGordon2017SignalAnalysis,wired2023signalhack}. Messaging apps may still leak
information through patterns such as message timing or background system
activity—even when message payloads are encrypted.

Addressing these challenges requires a comprehensive understanding of how messaging
apps are structured and how they behave at runtime. This thesis adopts a hybrid
approach that combines static analysis—examining app manifests, permissions,
and embedded components—with kernel-level tracing of live system calls to
capture detailed behavioral evidence \cite{BPFroid2021,AOSP2024Ftrace}. Kernel-level tracing is a powerful
technique for runtime visibility: tools such as \texttt{ftrace} \cite{ftrace2023} and \texttt{kprobes} \cite{kprobes2023}
record system-call activity with minimal overhead, offering fine-grained insights
into how an application interacts with operating system resources
. Despite its potential, only a handful of
studies have systematically applied this method to messaging apps
\cite{SLR2025Messaging}, despite their widespread and sensitive use—including
by government and military officials \cite{Politico2025Signal}.

\section{Motivation and Problem Statement}

\paragraph{Motivation}
The motivation behind this research arises from the necessity to bridge existing
gaps between user expectations, regulatory compliance, and the actual operational
behavior of popular messaging applications. Messaging apps process extensive personal
data, creating substantial risks related to privacy violations and security breaches \cite{ArsTechnica2018}.
Recent incidents involving unauthorized data collection by prominent messaging
applications, along with revelations about governmental use of supposedly secure
messaging platforms, underscore significant concerns regarding transparency
and user trust.\cite{ArsTechnica2018, Reuters2021WhatsAppExodus, Politico2025Signal}.

\paragraph{Problem Statement}


Although previous work has addressed various facets of Android application security and behavior, comprehensive comparative studies of privacy-sensitive messaging apps that combine static security inspection with systematic kernel-level tracing remain limited \cite{DynamicSecurityAnalysis2023}. As a result, critical aspects of both declared configurations (e.g., permissions, exported components) and actual runtime behavior—including low-level system interactions—within popular messaging applications, such as their handling of sensitive user data and background mechanisms, are still insufficiently understood.
\section{Research Objectives}

The specific research objectives addressed in this thesis are categorized as follows:

\subsection*{Primary Objective}

To generate a distinct privacy and behavioral profile for each application, and to devise a robust, hybrid tracing methodology that uncovers data-minimisation breaches, permission–runtime mismatches, and hidden data access, while contrasting privacy-centric messengers (e.g., Signal) with mainstream platforms.
\subsection*{Analytical and Technical Sub-Objectives}
\begin{itemize}
\item Record the actual kernel-level behavior of widely used messaging applications by developing a tracing and profiling framework using ftrace and kprobes.
\item Classify system calls into functional categories (file access, networking, IPC).
\item Collect and analyze kernel-level usage statistics per application.
\item Correlate static findings with dynamic behavior to highlight security and privacy risks.
\item Implement a web-based dashboard for behavior and network visualization.
\end{itemize}

\subsection*{Broader Goals}
\begin{itemize}
\item Enhance transparency in how messaging apps behave at system level.
\item Improve user awareness of hidden behaviors executed in the background.
\item Demonstrate the value of hybrid analysis for security and privacy evaluation.
\item Provide a structured and reproducible methodology for privacy-respecting
behavior analysis.
\end{itemize}

\section{Research Questions}
Based on the motivation and objectives, this thesis aims to address the following
research questions:

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q1.} What systematic methodology can be used for a comparative security and privacy analysis of mobile messaging applications?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q2.} Is \emph{static} analysis alone sufficient to uncover privacy-intrusive behaviour, or do kernel-level traces reveal additional hidden operations and syscall patterns?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q3.} Which system calls do popular messaging apps issue during normal use, and how do these calls align with—or diverge from—their declared permissions?
}}

\vspace{0.5em}
\noindent\fbox{\parbox{\textwidth}{
\textbf{Q4.} How do privacy-centric apps (e.g., \textit{Signal}) compare to mainstream platforms in terms of data minimisation, syscall footprint, and overall privacy posture?
}}

\section{Limitations of the Study}

To provide a realistic perspective on the scope of this thesis, it is important to distinguish between constraints that arise from project-specific conditions and those inherent to kernel-level behavioural analysis and static inspection.

\vspace{0.3cm}

\textbf{Project-Specific Constraints.}

\begin{itemize}
\item \textit{Timeframe:} The work was conducted within the timeframe of an undergraduate thesis, which constrained the number of test iterations, devices, and workload scenarios. For instance, only text messaging, voice clips, and image sharing were evaluated dynamically, while video calls—which would likely introduce significant additional real-time UDP streams—were not included.
\item \textit{Hardware Diversity:} Runtime tracing was performed on a limited set of consumer-grade Android devices. Results may not generalise to devices with custom ROMs, or older low-end hardware where kernel instrumentation behaves differently.
\item \textit{App Selection:} The analysis covered only three prominent instant messaging clients (Messenger, Telegram, Signal). Other messaging or region-specific apps, as well as system-bundled communication tools, were excluded, potentially leaving out unique interaction or security patterns.
\item \textit{Infrastructure Limitations:} Local storage and compute capacity limited the duration and granularity of traces. High-frequency events or prolonged sessions could not be captured exhaustively without incurring unsustainable storage overhead.
\end{itemize}



\textbf{Domain and Methodological Constraints.}
\begin{itemize}
\item \textit{Package Scope:} The mapping algorithm reliably lists user-installed APKs but excludes protected system apps like Chrome.

\item \textit{Trace Volume:} Continuous tracing generates large raw data with redundant or low-entropy segments; filters and time limits reduce size but may omit rare behaviors.
\item \textit{Attribution Noise:} Shared system services (e.g., \texttt{servicemanager}) introduce IPC noise, causing possible cross-app misattribution.
\item \textit{Network Depth:} The network layer analysis focused on event-level capture without deep packet inspection or full protocol parsing.
\end{itemize}

Overall, these limitations do not compromise the core findings but should be kept in mind when interpreting and generalising the results.
\section{Contributions of this Thesis}

This thesis makes the following key contributions to the field of mobile security and privacy analysis:

\begin{enumerate}[label=\roman*.]
    \item Identifies critical privacy-related insights, including discrepancies between user-revoked permissions and sustained data access, and reveals hidden runtime behaviors such as persistent sync adapter states and indirect inter-process communication.
    \item Proposes and implements an enhanced kernel-level tracing methodology, building upon the SliceDroid framework, enabling precise monitoring of mobile application runtime behavior.
    \item Provides a systematic hybrid analysis approach combining static and dynamic methods, resulting in comprehensive behavioral profiles for security-critical applications.
    \item Develops and integrates a custom package-to-process name mapper, allowing accurate identification and attribution of runtime events to the corresponding commercial application, even when system-level identifiers differ.
    \item Delivers an in-depth comparative analysis of three major messaging applications (Signal, Telegram, Meta Messenger), highlighting significant architectural and operational differences impacting user privacy.
    \item Statistically validates observed differences through rigorous inferential testing (ANOVA and Tukey HSD), offering robust, evidence-based conclusions.
\end{enumerate}


\section{Thesis Outline}
This thesis is organized into the following chapters:

\textbf{Chapter 1 – Introduction:} Presents the rise of mobile messaging and privacy risks, highlights the limitations of Android permissions and E2EE, motivates the combined static and dynamic approach, and states the thesis goals, research questions, and scope.

\vspace{0.4em}
\textbf{Chapter 2 – Related Work:} Reviews static security analysis, user-space and kernel-space dynamic instrumentation, and prior privacy studies on messaging apps, pinpointing the gap in systematic inspection of declared configurations alongside runtime profiling.

\vspace{0.4em}
\textbf{Chapter 3 – Technical Background:} Provides an overview of the Android architecture relevant to this study, introduces key system components and security features, and describes characteristics of the selected messaging applications.

\vspace{0.4em}
\textbf{Chapter 4 – Methodology \& System Design:} Describes the overall approach, detailing two complementary pipelines: one for static inspection and another for dynamic tracing.

\vspace{0.4em}
\textbf{Chapter 5 – Results:} Presents the outcomes derived from both pipelines: static findings such as manifest structures, permission declarations, and embedded third-party modules, alongside dynamic measurements of syscall distributions, permission–behavior mismatches, and comparative visual summaries of privacy-relevant runtime patterns.

\vspace{0.4em}
\textbf{Chapter 6 – Discussion:} Relates results to the research questions, and suggested improvements.

\vspace{0.4em}
\textbf{Chapter 7 – Conclusions:} Summarises contributions, highlights the static–dynamic tracing synergy, and notes future research directions.

\vspace{0.4em}
\textbf{Appendix A – Source Code:} Key implementation script supporting the App Mapper functionality.


% --------------------------------------------------
%  Chapter 2 – Related Work
% --------------------------------------------------

\chapter{Related Work}\label{ch:related}

The purpose of this chapter is twofold: (i) to review existing Android application analysis approaches, with a focus on kernel-level tracing methods, and (ii) to
clearly demarcate the research gap that this thesis addresses.  The survey is
organised top‑down, gradually narrowing the focus from general program analysis
techniques to the specialised problem of privacy‑oriented behavioural
profiling of popular messaging applications.

\section{Static Analysis of Android Applications}
\label{sec:rw:static}

Static analysis inspects an APK's bytecode and manifest offline, allowing security vetting to run quickly, deterministically, and at scale. It therefore plays a foundational role in Android app auditing, offering early detection of potential vulnerabilities without requiring runtime execution. Over the last decade, research in this area has evolved significantly, moving from foundational permission analysis to sophisticated data-flow tracking and machine learning models to address challenges like inter-component communication and code obfuscation.

\subsubsection{i) Permission and Manifest Analysis}
Initial research focused on understanding the Android permission model itself. Foundational work by Felt et al. provided a deep dive into how permissions are declared in the manifest, requested by applications, and interpreted (or misinterpreted) by users~\cite{felt2011androidprivacy}. These early studies established that declared permissions alone are often insufficient to predict malicious behavior, motivating the need for deeper code analysis.

\subsubsection{ii) Privacy-Oriented Taint Analysis}
To understand data misuse, research shifted to tracking information flows from sensitive \emph{sources} (e.g., contact lists) to security-critical \emph{sinks} (e.g., network sockets). \textbf{FlowDroid} set a new standard by introducing context-, flow-, field-, and object-sensitivity alongside an accurate activity lifecycle model, dramatically reducing false positives~\cite{arzt2014flowdroid}. On the \emph{DroidBench} benchmark suite, it achieved 93\% recall and 86\% precision, outperforming contemporary tools and scaling to large, real-world applications.

\subsubsection{iii) Inter-Component Communication (ICC) Analysis}
A primary limitation of early taint analysis was its inability to track data flows across process boundaries. To address this, \textbf{IccTA} augmented FlowDroid with an explicit ICC model, accurately mapping data passed through Intents and other IPC mechanisms~\cite{li2015iccta}. It surpassed earlier tools like \textbf{Epicc}~\cite{octeau2013epicc} and \textbf{CHEX}~\cite{lu2012chex} on the \emph{ICC-Bench} suite. \textbf{Amandroid} extended this concept by constructing a full inter-component data-flow graph, uncovering previously unknown vulnerabilities in hundreds of Play Store apps~\cite{wei2014amandroid}.

\subsubsection{iv) Resilience to Obfuscation}
As developers began using techniques like reflection, dynamic code loading, and native libraries to obscure behavior, static analysis tools had to adapt. \textbf{DroidRA} was designed to resolve reflective calls by using constant propagation to rewrite them into direct invocations, boosting FlowDroid’s precision on reflection-heavy code by up to 60\%~\cite{li2016droidra}. Other approaches like \textbf{DexLEGO} reassemble bytecode captured at runtime for static analysis~\cite{ning2019dexlego}, while \textbf{LibDroid} specifically focuses on summarizing taint propagation within native C/C++ libraries~\cite{libdroid2022}, progressively widening the statically visible attack surface.

\subsubsection{v) Learning-Based Malware Detection}
A separate research strand moved beyond handcrafted rules towards machine learning. \textbf{Drebin} pioneered this by extracting lightweight syntactic features (permissions, API calls, etc.) from the manifest and bytecode to train a linear SVM classifier. It detected malware with 94\% accuracy on a large dataset of 5,560 samples~\cite{arp2014drebin}. More recently, deep learning models like \textbf{DL-AMDet} have employed architectures combining CNNs and LSTMs to achieve near-perfect accuracy on public datasets~\cite{nasser2023dlamdet}, though their limited interpretability remains a challenge for high-assurance systems.

\subsubsection{vi) Practical Analysis Toolkits}
This body of research has culminated in powerful, extensible toolkits for practical security auditing. \textbf{MobSF} (\emph{Mobile Security Framework}) integrates static and dynamic analysis, reverse engineering, and malware scoring in a user-friendly web interface~\cite{mobsf2023}, while \textbf{Androguard}, a Python-based library, provides the foundational components for building custom reverse engineering and analysis pipelines~\cite{androguard2023}. This thesis leverages both of these foundational tools: MobSF is employed for initial, broad-spectrum security scanning, while Androguard provides the programmatic basis for the custom static analysis scripts detailed in Chapter~4.

\medskip
\noindent\textbf{Synthesis.}
Static analysis has achieved substantial advances in precision and scale, evolving from simple manifest checks to sophisticated data-flow and machine learning models. Yet, it remains fundamentally constrained by its inability to observe runtime-specific behavior, implicit data flows, or dynamically loaded code. These blind spots, especially critical in privacy contexts, motivated the development of dynamic and hybrid approaches that can capture an application's \emph{actual} behavior under real-world conditions.


\section{User-Space Dynamic Instrumentation}
\label{sec:rw:dynamic:user}

Whereas kernel tracing offers a \emph{system-wide} vantage, user-space dynamic instrumentation injects probes \emph{inside} the app process, exposing rich semantic context—class names, parameters, and UI callbacks—without requiring a custom kernel. The literature has evolved along several complementary strands that echo, in spirit, the structure reviewed for static analysis.

\subsubsection*{(i) System-Call Monitors}
Early approaches used the \texttt{ptrace} mechanism to intercept system calls externally. \textbf{DroidTrace}, for example, hooks every \texttt{ptrace} event to log the full system-call stream and can \emph{force} rare code branches to execute, increasing coverage~\cite{zheng2014droidtrace}. A later study demonstrated that it is possible to reconstruct high-level Android API invocations purely from syscall sequences, highlighting the semantic power of these low-level traces~\cite{nisi2019syscall}. While these tools deploy on stock ROMs, they incur measurable overhead and cannot observe internal Java-level logic.

\subsubsection*{(ii) Dynamic Binary Instrumentation (DBI)}
For analyzing native code, instruction-granular DBI engines like \textbf{Pin} (ported to ARM) enable fine-grained tracing, but suffer from high runtime cost and outdated Android support. More modern frameworks like \textbf{QBDI} improve portability to ARM/ \\Thumb-2 and withstand common anti-analysis techniques, although they remain native-only and typically require root privileges~\cite{qbdiblackhat2020}.

\subsubsection*{(iii) ART-Level Hooking Frameworks}
A powerful category of tools modifies the Android Runtime itself to intercept method calls across the entire system. The most prominent example is the \textbf{Xposed Framework}, which alters the Zygote process to load custom modules at startup. This allows developers to hook, modify, and replace any Java method in any application, offering unparalleled control over app behavior~\cite{xposed}. While extremely powerful, this approach requires root access and system modification, which can break security features like SafetyNet and make it unsuitable for analyzing unmodified consumer devices.

\subsubsection*{(iv) In-Process Hooking Frameworks}
In contrast to system-wide modification, tools like \textbf{Frida} inject a loader into a specific target process at runtime. This loader JIT-compiles JavaScript hooks into native code, permitting live patching of Java, JNI, and native functions for interactive experiments~\cite{frida2020}. \textbf{DYNAMO} builds upon Frida to perform systematic differential analysis of framework evolution across Android versions~\cite{dynamo2021}, while \textbf{InviSeal} hardens Frida against detection and reduces its overhead to less than 3\%~\cite{inviseal2023}. However, these tools struggle with tamper-aware apps and are confined to a single process, leaving cross-app and kernel-level events hidden.

\subsubsection*{(v) Sandboxes and Emulators}
To automate analysis at scale, containerised sandboxes like \textbf{C-Android} isolate apps within Linux namespaces for reproducible testing~\cite{candroid2019}. Emulation-centred pipelines (e.g., \textbf{DynaLog}) automate malware triage by collecting runtime features in parallel VMs~\cite{dynalog2016}. Although high-throughput, these environments often diverge from real-device hardware and timing, and they are easily fingerprinted by sophisticated malware.

\medskip
\noindent\textbf{Synthesis.}
User-space instrumentation shines in its \emph{semantic richness}, rapid deployment, and interactive control, making it ideal for annotating a coarse kernel trace with method names, intent actions or UI context. Its weaknesses—visibility gaps below the syscall boundary, susceptibility to anti-hooking defences, and non-negligible overhead—underscore why kernel-level tracing remains the authoritative foundation for our behavioural profiling. In our study, we therefore treat user-space hooks as an \emph{auxiliary lens} to validate and enrich the low-level, system-wide evidence captured by our kernel monitors.

\section{Kernel-Level Tracing Infrastructures}
\label{sec:rw:kernel}

Tracing infrastructures at the kernel level offer a privileged vantage point beneath the Android framework, the ART runtime, and native user-space libraries. By instrumenting key OS subsystems—such as system calls, Binder IPC, and network interfaces—they expose low-level behavioral signals while incurring minimal runtime overhead. These signals are especially critical when applications encrypt payloads or obfuscate logic, rendering user-space instrumentation ineffective.

These infrastructures are built upon foundational Linux kernel mechanisms. In contrast to high-overhead, process-level tracers like \texttt{strace}~\cite{strace2023}, modern approaches leverage highly efficient in-kernel frameworks. These include \texttt{ftrace}~\cite{ftrace2023}, the kernel's native function tracer; \texttt{kprobes}~\cite{kprobes2023} for dynamic function instrumentation; and \texttt{eBPF}~\cite{ebpf2023}, which allows for safe, programmable tracing directly within the kernel. The literature applying these tools can be grouped as follows:

\subsubsection*{(i) eBPF- and ftrace-Based Collectors}
Modern frameworks such as \textbf{BPFroid} leverage eBPF and ftrace to capture fine-grained telemetry from stock Android kernels without requiring firmware modifications~\cite{BPFroid2021}. BPFroid monitors per-UID syscall sequences, Binder transactions, and network activities, enabling malware detection with low system overhead ($\sim$3\% energy cost). Earlier efforts, such as \textbf{ID-Syscall}, used loadable kernel modules on Android 4.x to demonstrate that syscall n-grams alone can suffice for binary classification of app behavior~\cite{Schmidt2009IDSyscall}, though such systems lacked semantic context and cross-process correlation.

\subsubsection*{(ii) Network-Centric and Covert-Channel Tracing}
Beyond explicit syscall logs, more covert behavioral signals have also been explored. Celik and Gligor extract timing-based features from standard ftrace logs to detect stegomalware, highlighting how packet sizes and inter-packet gaps reveal anomalous communication even without payload inspection~\cite{celik2021stego}. These techniques operate under encryption but often omit Binder IPC, which is central to Android’s inter-component messaging model.

\subsubsection*{(iii) Hardware-Assisted Monitors}
Low-level performance monitoring units and instruction tracing extensions like ARM’s Embedded Trace Macrocell (ETM) provide hardware-level insights with near-zero perturbation. For example, \textbf{HART} captures execution traces from proprietary kernel modules, offering unmatched visibility~\cite{zhang2020hart}. However, such approaches face practical limitations: ETM is often disabled in production smartphones, lacks mapping to user-level processes, and requires privileged access, constraining its applicability.

\subsubsection*{(iv) Production-Scale Tracing}
Industrial-grade pipelines such as Google’s \textbf{Perfetto} aggregate diverse sources, including ftrace and Binder logs—into rich, SQL-queryable trace files for profiling performance metrics like startup time and UI latency~\cite{maganti2022perfetto}. While primarily for performance diagnostics, such infrastructures are underutilized for security research. Complementary systems like \textbf{eMook} extend Perfetto by integrating per-PID eBPF filters, reducing overhead by 85\% and enabling longitudinal field studies~\cite{williams2024emook}.

\medskip
\noindent\textbf{Synthesis.}
Kernel tracing offers a hard-to-tamper, always-on lens but must still tame four hurdles: the semantic gap, opaque data, privilege requirements and data volume. Recent work narrows these by pairing syscalls with Binder provenance, granting BPF rights via SELinux instead of root, and summarising high-rate events in-kernel—pushing low-overhead, whole-system reconstruction onto stock phones.


\section{Privacy Studies on Messaging Applications}
\label{sec:rw:privacy-im}

End-to-end encryption neutralises classical content-centric attacks, but it does not guarantee \emph{privacy}. Over the last decade, researchers have investigated three complementary vectors through which popular messaging apps still expose sensitive information.

\subsubsection*{(i) On-Device Artefacts and Forensics}
Early work focused on residual data stored locally. Anglano’s systematic analysis of WhatsApp on Android~4.x recovered chat databases, media thumbnails, and contact lists even after user-initiated deletions~\cite{anglano2015whatsapp}. Subsequent studies extended the corpus to Telegram, Signal, and Viber, showing that cached profile photos, push-notification logs, and SQLite WAL files can reveal conversation partners and group identifiers~\cite{moltchanov2018telegram, obermeier2018signal}. While modern OS versions encrypt local backups, notification side-channels (e.g., Firebase tokens) remain an open avenue for investigation~\cite{berezowski2020push}.

\subsubsection*{(ii) Network-Level Traffic Analysis}
A second strand exploits packet timing, size, and sequence to infer user actions without breaching encryption. Pioneering work by Matic \emph{et al.} fingerprinted iMessage events (send, read, typing) with over 90\% accuracy solely from TLS record bursts~\cite{matic2015iMessage}. Apthorpe demonstrated similar leakage for Android IM apps over Wi-Fi~\cite{apthorpe2018smart}. Recent machine-learning classifiers identify not only event types but also multimedia uploads and voice-over-IP handshakes in QUIC traffic~\cite{lee2023quic}. Countermeasures such as adaptive padding have been proposed, which raise bandwidth by 8–14\% while mitigating most classifiers~\cite{poblete2021defence}.

\subsubsection*{(iv) Metadata Policies and Compliance Audits}
A complementary line of research audits whether apps meet their self-declared privacy policies. Egele’s longitudinal crawl of Telegram channels uncovered the retention of deleted media on CDN edge nodes weeks after deletion~\cite{egele2019cdn}. Bock dissected Signal’s sealed-sender protocol, confirming that only sender and receiver metadata persist in a 24-hour service log but flagging the exposure of push-token identifiers to Apple/Google~\cite{bock2020sealed}. Recent GDPR-oriented studies show that less than 40\% of messaging apps provide complete data-export facilities despite legal requirements~\cite{frolov2022gdpr}.

\medskip
\noindent\textbf{Synthesis.}
Existing studies often rely on intrusive forensics, controlled testbeds, or static policy analysis. While a comprehensive understanding remains challenging, it appears that there is a limited body of work that fully combines kernel-level traces with the aforementioned insights to derive a live, system-wide privacy profile. Our work endeavors to contribute towards bridging this potential gap by analyzing kprobe/ftrace events (such as Binder calls, network bursts, and wakelocks), thereby proposing a runtime taxonomy of privacy-relevant behaviours in Messenger, Telegram, and Signal.
\section{Research Gap}
\label{sec:rw:gap}

As the review demonstrates, each analytic strategy inherently possesses its own weaknesses, each with inherent trade-offs.

\emph{Static inspection} (e.g., code-review and manifest checks) is efficient and scalable but fundamentally struggles with behaviours that surface only at run time, such as those involving dynamic code loading or heavy obfuscation~\cite{li2016droidra, feng2020survey}.

\emph{User-space monitors}—such as taint-tracking or framework hooks—offer richer semantic context. Yet, they typically require a modified or rooted runtime~\cite{xposed, enck2014taintdroid}, can be detected and evaded by well-crafted apps~\cite{inviseal2023}, and must often place implicit trust in the behavior of native code libraries.

Finally, \emph{kernel-level tracing} delivers a low-overhead and tamper-resistant vantage point, but the raw syscalls and Binder op-codes it yields expose little direct semantic intent. This creates a considerable "semantic gap" between low-level system events and high-level application logic, a challenge actively being researched~\cite{nisi2019syscall}.

Taken together, these observations point to a clear methodological gap: there is a need for techniques that combine the high-fidelity visibility of kernel-level tracing with the contextual insights of static analysis. This gap is particularly pronounced in the domain of messaging applications. While numerous studies have analyzed these apps from a digital forensics or network-level metadata perspective~\cite{arxiv2020metadata}, the application of system-wide runtime monitoring remains limited.

This thesis addresses this twofold gap by proposing a framework that not only integrates static and kernel-level dynamic analysis but also applies it systematically to profile the privacy-relevant behaviors of popular messaging apps. Designed for practical use, our system operates on stock consumer devices and, while it requires root privileges for kernel instrumentation, it avoids the need for custom firmware or kernel recompilation. It achieves its accessibility and minimizes complex configuration through a fully automated analysis pipeline and an interactive web-based dashboard for intuitive visualization of the collected behavioral evidence.

% --------------------------------------------------
%  Technical Background
% --------------------------------------------------
\chapter{Technical Background}

This chapter provides a detailed overview of technical background necessary for understanding the methodology and objectives of this thesis. First, it presents the architecture of the Android operating system, focusing particularly on the Linux-based kernel and how applications interact with it. Next, it discusses the behavior and privacy concerns related to messaging applications, highlighting known issues and relevant technical aspects.

\section{Android Architecture}

\subsection{Android Software Stack Overview}
Android is a layered, open-source mobile operating system built on top of a customized version of the Linux kernel \cite{AOSPArchOverview}. Its architecture is designed to be modular and extensible, supporting a wide range of hardware while enforcing clear boundaries between components. The Android software stack is composed of several interconnected layers, typically including the Application Layer, the Java API Framework (or Application Framework), the Android Runtime (ART) and Native Libraries, the Hardware Abstraction Layer (HAL), and the Linux Kernel itself \cite{tanenbaum2015modern}.

The Application Layer hosts both system and user-installed applications. These applications interact with the system via APIs exposed by the Android Framework. The Java API Framework provides access to core system services such as activity management, resource handling, content providers, and telephony. Services like \texttt{ActivityManager}, \texttt{WindowManager}, and \texttt{PackageManager} facilitate the lifecycle management and orchestration of application behavior.

Beneath the framework lies the Android Runtime (ART), which executes application bytecode and optimizes it using ahead-of-time (AOT), just-in-time (JIT), or interpretation modes \cite{AOSPART}. Alongside ART are native libraries written in C/C++, including performance-critical components such as WebView, OpenSSL, and the Bionic libc. The Java Native Interface (JNI) allows managed Java/Kotlin code to call into these native libraries.

The HAL acts as a bridge between the Android Framework and the hardware drivers residing in the kernel. It defines standard interfaces that vendors implement to support various hardware components like audio, camera, sensors, and graphics. Since Android 10, Google introduced the Generic Kernel Image (GKI), which aims to further separate the vendor-specific hardware implementations from the core Linux kernel by introducing a stable kernel interface \cite{AOSPGKI}. This allows devices from different manufacturers to share a common kernel base while maintaining vendor-specific modules separately, simplifying updates and enhancing portability.

At the lowest level, the Linux kernel provides essential operating system services such as process scheduling, memory management, networking, and security enforcement \cite{love2010linux}. Android extends the kernel with additional features including the Binder IPC driver, ashmem (anonymous shared memory), and wakelocks to manage power usage \cite{feng2020survey}. This kernel foundation ensures that resource access is isolated and controlled across all system layers.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{android_stack_diagram.png}
    \caption{Diagram of Android Software Stack (source: Android Developers Guide~\cite{AOSPArchOverview}).}
    \label{fig:android_stack}
\end{figure}

\subsection{Application Layer and Process Lifecycle}
At the application layer, Android executes user and system applications packaged in APK format. Each APK includes compiled DEX bytecode, resources, native libraries, and a manifest file that defines app components and permissions. Apps run in sandboxed processes, each forked from the Zygote daemon—a minimal, preloaded system process that speeds up app launch time by sharing memory using copy-on-write \cite{AOSPArchOverview}.

The lifecycle of applications is centrally managed by the \texttt{ActivityManagerService} (AMS), which coordinates activity transitions, memory prioritization, and process states (foreground, background, cached). The \texttt{PackageManagerService} (PMS) handles component registration and permission declarations based on the manifest.

Apps follow a component-based model: Activities, Services, Broadcast Receivers, and Content Providers. These components interact with the system and one another via well-defined lifecycles and IPC through the Binder driver. Operations like binding to a service or launching an activity initiate system-level behavior—such as context switches or memory allocations—which are visible in syscall traces.

Binder IPC enables structured communication between app components and system services. Messages are serialized as Parcel objects, routed through the Binder driver, and trigger observable kernel events. These include context switches and transaction dispatches, which are measurable using tools like ftrace or kprobes.

\subsection{Android Runtime, Native Layer, and JNI}
The Android Runtime (ART) executes application bytecode using a combination of ahead-of-time (AOT), just-in-time (JIT), and interpretation mechanisms \cite{AOSPART}. From a kernel-level tracing perspective, JIT-related memory operations may trigger system calls such as \texttt{mmap()}, \texttt{write()}, and \texttt{mprotect()}, as ART dynamically allocates memory for optimized code.

Beyond execution, ART interacts with the kernel to manage thread scheduling and memory access—behaviors that appear in system call traces. In dynamic analysis, such patterns can be correlated with app lifecycle events or anomalous execution spikes.

JNI further extends the runtime by enabling Java/Kotlin code to invoke native C/C++ libraries \cite{AOSPJNI}. These native operations often bypass standard framework controls, introducing low-level file, network, or cryptographic actions. This is particularly relevant for behavioral profiling, as native code may perform sensitive operations that differ from those visible at the Java level.

In the context of this thesis, which focuses on dynamic kernel-level analysis, capturing system interactions initiated by ART and JNI is essential. It enables the identification of execution phases or modules that deviate from expected behavior—especially in apps that rely heavily on native components for messaging, encryption, or background communication. The sequence of events during JNI initialization is illustrated in Figure~\ref{fig:jni_init}. It begins when the VM loads the application class, triggering a static initializer which invokes the native \texttt{JNI\_OnLoad()} function. This function registers native methods and returns the \texttt{JNI\_Version}, after which Android proceeds with the usual application lifecycle (e.g., \texttt{onCreate()}) managed by the \texttt{ActivityManager}. This interaction flow is especially relevant in behavioral analysis, as native components may introduce low-level behavior patterns not observable through the Java layer alone.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{jni_init_flow.png}
    \caption{Sequence diagram showing the JNI initialization flow in an Android application.}
    \label{fig:jni_init}
\end{figure}

\subsection{Linux Kernel Fundamentals and System Calls in Android}
The Android operating system relies on the Linux kernel as its foundational layer for managing hardware resources, abstracting device drivers, and ensuring secure process isolation \cite{love2010linux}. All interactions between user applications and hardware components are mediated through the kernel’s system call interface, making it a critical observation point for behavioral profiling.

Each time an application requests a low-level operation—such as reading a file, accessing a sensor, or opening a network socket—it invokes one or more system calls, which switch execution from user space to kernel space. In Android, these calls are typically issued via the Bionic libc, which serves as the system’s C standard library, or directly through Java Native Interface (JNI) bindings when applications rely on native code for performance-critical tasks. Capturing these calls reveals how an application actually uses system resources, regardless of its declared permissions or documented features.

Android’s kernel extends the standard Linux design with additional components such as the Binder IPC driver for efficient inter-process communication, ashmem for shared memory management, and wakelocks for fine-grained power control \cite{AOSPArchOverview}. These features generate distinctive kernel-level events that tracing tools can capture to uncover hidden or background activities in messaging apps.

\subsection{Android Security Model and Isolation Mechanisms}
Android enforces a layered security model combining Linux kernel features with user-space controls. Each application runs in its own sandbox, identified by a unique UID and GID, restricting file and device access. This is complemented by the use of SELinux in enforcing mode, which uses MAC policies to define allowable interactions between system components and applications \cite{AOSPSecurity}.

Filesystem isolation further ensures that apps can only access their designated directories (e.g., \texttt{/data/data/{package\_name}}). Attempts to traverse or access other app spaces are blocked unless the app has elevated privileges or exploits kernel vulnerabilities.

System call filtering through seccomp restricts the range of calls an app can make, reducing the kernel's attack surface. From a profiling standpoint, observing unauthorized system calls or failed access attempts provides insight into potentially malicious or privacy-invasive behavior.

\section{Messaging Apps: Characteristics and Privacy Implications}

\subsection{Functional Overview}
Messaging applications are among the most widely used mobile software categories, providing real-time communication, media sharing, group messaging, and voice/video calling capabilities. Popular platforms such as Signal, Telegram, and Facebook Messenger serve billions of users globally, integrating deeply into daily communication routines.

Android, as the dominant mobile operating system, provides the primary distribution platform for these apps through the Google Play Store. According to public data, Facebook Messenger has surpassed 5 billion downloads, Telegram exceeds 1.2 billion downloads, and Signal has more than 100 million installs \cite{StatistaMessenger, StatistaTelegram, StatistaSignal}. While usage varies by region, these numbers highlight the ubiquity and market penetration of messaging applications on Android devices.

Such widespread deployment across diverse hardware and Android configurations introduces heterogeneous behaviors in terms of network communication patterns, lifecycle management, and system-level operations. This diversity, combined with varying security practices among apps, renders them ideal candidates for behavioral profiling at the kernel level.

These applications typically rely on key Android components to support their functionality: foreground \texttt{Services} are used for persistent communication sessions, \texttt{Broadcast Receivers} handle asynchronous events such as network connectivity or message reception, and \texttt{Content Providers} facilitate access to structured data such as shared databases. All applications are packaged in APK format and structured using component declarations in the \texttt{AndroidManifest.xml} file \cite{AOSPArchOverview}.

Rather than detailing cryptographic implementations or privacy architectures here, which are explored in Section 2.2.3, this section focuses on the foundational aspects of app deployment, runtime behavior, and Android system integration that are relevant for low-level behavioral tracing.

\subsection{Privacy-Critical Behaviors and Resource Usage}
Messaging applications often initiate background services using components like \\
\texttt{JobScheduler}, \texttt{AlarmManager}, and foreground services to maintain persistent communication channels—frequently waking the device from idle states using wakelocks \cite{AOSPWakelocks}.

Resource access is another key concern. Most messaging apps request access to sensitive resources such as contacts (\texttt{READ\_CONTACTS}), device location, microphone (\texttt{RECORD\_AUDIO}), and camera (\texttt{CAMERA}). While many of these are used legitimately during active user sessions (e.g., voice/video calls, media sharing), kernel-level traces often reveal such accesses occurring in the background without any visible UI activity—raising potential privacy concerns \cite{enck2014taintdroid}.

Additionally, messaging apps rely on push notification services such as Firebase Cloud Messaging (FCM), which has superseded Google Cloud Messaging (GCM), to deliver messages. These services necessitate persistent TCP connections and background listeners that, when profiled, result in recurring system calls like \texttt{recvmsg()}, \texttt{poll()}, or \texttt{select()}. Furthermore, apps such as Facebook Messenger are known to incorporate third-party SDKs (e.g., for analytics or ads) that initiate background network connections and file I/O unrelated to core messaging functionality \cite{ShenVervierStringhini2021}.

Metadata collection—such as timestamps, contact hashes, or device identifiers—is another privacy-relevant behavior. Even apps that implement strong encryption at the message content level (like Signal) may still generate system call activity that reflects metadata-related operations (e.g., \texttt{stat()}, \texttt{write()}, \texttt{getuid()}) \cite{arxiv2020metadata}.

Finally, the use of native code through JNI can introduce kernel-visible activity that bypasses Android’s permission mediation layer. This is especially relevant for apps that offload cryptographic or media processing to native components. System call traces such as \texttt{mmap()}, \texttt{ioctl()}, and \texttt{openat()} often appear in these cases and can be captured using ftrace or kprobes.

These behaviors underscore the necessity of dynamic, syscall-level observation for detecting privacy-relevant activity and serve as foundational evidence in the behavioral profiling framework proposed in this thesis.

\subsection{Architectures, Privacy, and Cryptographic Models}
Messaging applications adopt distinct architectural and cryptographic frameworks that critically influence their privacy characteristics and observable behaviors at the kernel level. The majority of messaging platforms—including Signal, Telegram, and Facebook Messenger—use centralized client-server architectures, where backend servers handle communication routing, message storage, and authentication. Centralization supports multi-device synchronization and cloud storage but introduces privacy risks, such as metadata accumulation and continuous background socket activity (e.g., \texttt{connect()}, \texttt{poll()}, \texttt{recvmsg()}).

Signal utilizes a centralized yet privacy-focused architecture, relying exclusively on the Signal Protocol, a robust end-to-end encryption (E2EE) scheme ensuring forward secrecy, deniability, session-specific ephemeral keys, and the Double Ratchet algorithm for key management \cite{signalwhitepaper}. The Double Ratchet combines a Diffie-Hellman key exchange and symmetric key cryptography, generating new encryption keys for every message sent, significantly enhancing security against key compromise. Signal employs a custom Java implementation of the Signal Protocol known as libsignal, which provides cryptographic primitives and protocol management directly within Android applications, facilitating rigorous security auditing and simplifying integration. Kernel-level activities linked to Signal’s encryption involve system calls such as \texttt{getrandom()}, \texttt{mprotect()}, and \texttt{write()} during cryptographic operations. Signal's architecture avoids cloud synchronization and external dependencies, significantly reducing its syscall footprint.

Telegram implements a hybrid model, providing optional E2EE via "Secret Chats" but defaulting to server-side encryption \cite{moltchanov2018telegram}. Standard conversations store plaintext messages centrally, enabling synchronization but increasing metadata exposure. This design results in elevated kernel activity, particularly frequent \texttt{send()}, \texttt{recv()}, and \texttt{stat()} calls for persistent synchronization and message retrieval.

Facebook Messenger, a privacy-limited centralized system, has recently transitioned to offering default end-to-end encryption for one-to-one chats, moving beyond its historical reliance on an opt-in "Secret Conversations" mode for E2EE. Its prior default chat configuration incorporated numerous third-party SDKs for advertising and analytics and generated extensive background system calls such as \texttt{open()}, \texttt{socket()}, \texttt{unlink()}, and \texttt{connect()} \cite{ShenVervierStringhini2021}.

Storage models further distinguish these apps. Signal maintains exclusively local encrypted storage without cloud backups, minimizing kernel interactions. Telegram and Messenger utilize cloud synchronization for message histories, leading to increased kernel-level I/O operations (e.g., \texttt{open()}, \texttt{fsync()}, \texttt{stat()}).

Ephemeral messaging capabilities (disappearing messages) affect transient kernel behaviors, including short-lived file creation and memory operations like \texttt{madvise()}. Conversely, platforms that store logs or metadata generate repeated kernel interactions via persistent database accesses.

Finally, encryption key management significantly impacts syscall activity. Signal generates and securely stores keys locally using secure hardware or biometric-protected storage. Telegram and Messenger employ centralized key management, simplifying multi-device usage but requiring trust in backend infrastructure.

These architectural and cryptographic distinctions shape observable syscall behaviors, enabling kernel-level analysis to assess privacy implications effectively.
% --------------------------------------------------
%  Research Methodology
% --------------------------------------------------
\chapter{Methodology and System Design}

This thesis forms part of a broader research initiative focused on the security and behavioral analysis of Android applications using combined static inspection and custom kernel-level tracing. While the present work concentrates on profiling the runtime behavior of messaging apps for privacy analysis—by extending SliceDroid and correlating static and dynamic findings—related efforts by the research group explore aspects such as automated anomaly detection, enhanced portability of tracing scripts across devices, and offset-independent instrumentation techniques. These complementary topics fall outside the scope of this thesis but inform its design and future extensions.

\section{Research Design}

The research design adopts a hybrid static–dynamic methodology to systematically uncover and characterise behavioural and security aspects of contemporary Android messaging applications without intrusive instrumentation.

\subsection{Target Application Selection}

A key design decision was the careful selection of three representative Android messaging applications: \textit{Signal}, \textit{Messenger} (Meta), and \textit{Telegram}. This selection was not arbitrary but strategically motivated by the need to balance contrasting privacy models, popularity, feature diversity, and technical feasibility of analysis.

\textbf{Signal} was chosen as a privacy benchmark. It implements the widely respected open-source Signal Protocol, providing robust end-to-end encryption (E2EE) by design and exposing minimal metadata to intermediaries or servers. Its architecture prioritises decentralisation and ephemeral message storage, making it an ideal candidate to assess how a privacy-first approach is reflected both statically (in code) and dynamically (in runtime traces).

\textbf{Messenger}, developed by Meta, was selected as a mainstream, feature-rich counterpart. It dominates global markets with billions of active users and offers a vast array of integrated features—messaging, voice/video calls, payments, and third-party integrations. This complexity translates to richer permission usage, diverse IPC pathways, and potential privacy trade-offs, serving as a high-volume, real-world stress case for the hybrid analysis pipeline.

\textbf{Telegram} complements the corpus by introducing a hybrid architecture: it offers both cloud-based messaging (storing messages on remote servers by default) and opt-in secret chats that utilise local device storage and ephemeral encryption keys. Additionally, Telegram supports public channels and bots, introducing unique server-client interaction patterns. Its popularity among privacy-conscious users yet fundamentally different technical approach compared to Signal enriches comparative insights.

Selecting these three applications thus ensures coverage across a spectrum:
- From strict E2EE and minimum metadata (Signal),
- To mainstream commercial solutions with extended functionality (Messenger),
- To hybrid models blending cloud storage with privacy-enhanced modes (Telegram).

This deliberate triangulation ensures that the findings are generalisable and illustrate how different privacy philosophies and design trade-offs manifest in practical, widely deployed systems.

\subsection{Static Analysis Methodology}

Static analysis was employed as the initial phase of the hybrid approach due to its capacity to rapidly detect privacy-critical behaviors directly within application binaries without requiring execution. By systematically inspecting code structures, manifest configurations, and declared permissions, potential leakage vectors, risky API calls, and suspicious data flows can be flagged early, effectively narrowing the scope and complexity of the subsequent dynamic investigation.

For this purpose, two well-established tools were used in combination: \textsc{Androguard}~\cite{androguard2023} and the Mobile Security Framework (\textsc{MobSF})~\cite{mobsf2023}. Their integration provided both automation-friendly scripting and comprehensive security reporting capabilities. A detailed justification of why these specific tools were selected, along with their comparative strengths, is presented in Section~4.2.1 (\emph{Tool Selection and Rationale}).

\subsection{Dynamic Analysis Methodology}

Dynamic behavioural analysis leveraged kernel-level tracing to observe runtime interactions transparently and with high fidelity. This component extended the \textsc{SliceDroid} framework and was deployed on a rooted Android device with Magisk and an unlocked bootloader, granting controlled access to the kernel tracing filesystem (\texttt{tracefs}). Instrumentation leveraged \texttt{ftrace}, \texttt{kprobes}, ADB utilities, shell scripts, and Python post-processors to parse raw trace data into structured JSON suitable for behavioural profiling.

A design principle prioritised simplicity and reproducibility over advanced but more invasive technologies like eBPF. The use of \texttt{kprobes} and \texttt{ftrace} alone provided sufficient observability with minimal overhead and system impact, while remaining compatible with a wide range of device kernels.

Tracing sessions were orchestrated via bash scripts deployed on-device, dynamically registering and enabling probe points targeting sensitive kernel events relevant to IPC, resource access, and networking. Extracted traces were securely offloaded, filtered by process IDs, and cleaned with heuristics to remove noise.

Finally, behavioural summaries were visualised both statically—via Python tools like \texttt{matplotlib}—and interactively, through a custom Flask–D3.js web interface supporting timeline exploration and event-based drill-down.

Detailed implementation aspects and trace artefacts are discussed in the following chapters.

\section{Static Analysis Pipeline}

\subsection{Tool Selection and Rationale}

The static analysis phase relied primarily on two open-source tools: Androguard and MobSF. These tools were selected based on their usability, extensibility, and ability to produce structured, interpretable results suitable for early-phase exploration.

Androguard was chosen as the first-stage analyzer due to its lightweight nature and Python-based interface. It allows decompilation of APK files into Dalvik bytecode, extraction of manifest metadata, and traversal of call graphs. Its scripting capabilities enabled batch processing and direct generation of structured CSV reports. Specifically, the CSV file used in this study summarizes permission usage, class hierarchies, and API call references for quick inspection.

Following this, MobSF (Mobile Security Framework) was used for deeper inspection. MobSF is a versatile tool supporting both static and dynamic analysis through a unified web interface or API. It performs deep inspection of Android APKs and generates detailed PDF reports. In this study, MobSF's output included permissions, dangerous API patterns, intent filters, and trackers, as demonstrated by the PDF report generated for the APK's.

\subsection{Setup and Execution Workflow}

The APKs of the three messaging applications (Signal, Messenger, Telegram) were extracted directly from the device using ADB. These APKs were then analyzed using both Androguard and MobSF in separate environments.

Androguard was set up in a Python virtual environment on WSL2. After installing version 4.1.3 and its dependencies, a custom script was used to automatically extract information about permissions, component exposure, cryptographic usage, suspicious API calls, and code structure. The output was exported in structured CSV and JSON format, offering a quick behavioral profile for each application.

MobSF, on the other hand, was run through Docker for convenience and reproducibility. The official Docker image was used to launch the web-based analysis engine, which provided high-level reports summarizing potentially dangerous permissions, intent filters, trackers, and native libraries. Each PDF report enabled visual inspection and supported security triage.

Together, these tools offered a balanced combination of lightweight automated analysis and rich visual reporting, enabling a fast yet informative static assessment of each target application.


\subsection{Challenges and Limitations}

While Androguard and MobSF were successfully integrated into the pipeline, the broader landscape of static analysis tools for Android presented significant challenges. Several well-established tools proved difficult to use in practice. For example, FlowDroid required complex setup involving specific Java versions and Android platform SDKs, and frequently failed to resolve context-sensitive paths in larger applications. Similarly, tools like Amandroid and QARK either lacked active maintenance or had compatibility issues with recent APK formats and OS environments. In particular, several tools failed to handle APKs signed with modern signature schemes (v2/v3), or encountered class resolution errors due to obfuscated code and multidex structures. As a result, their integration was deemed impractical within the constraints of this study’s timeline and reproducibility requirements. This further justified the decision to rely on tools with minimal dependencies and verified stability, prioritizing efficiency over theoretical completeness.




\section{Dynamic Analysis Pipeline}
\subsection{Experimental Setup}

The experimental setup involves detailed technical preparation and precise procedures to ensure kernel-level tracing capability. The device selected was a OnePlus Nord CE 4 Lite (CPH2621, EU variant) running Android 15 (SDK 35). It supports System-as-Root (\texttt{isSAR=true}), features A/B partitioning (\texttt{isAB=true}), and includes an accessible ramdisk.

\subsubsection{Root Access and Boot Image Preparation}

The device was prepared for root access using Magisk, following guidelines from xda-developers. Developer Options, OEM Unlocking, and USB Debugging were activated. Android SDK Platform Tools were installed on the computer, with the path added to environment variables, enabling communication via ADB.

After obtaining the full OTA zip for the CPH2621 EU variant via Oxygen Updater, it was transferred to the computer and unpacked to extract the \texttt{payload.bin} file. Using Payload Dumper, the \texttt{boot image} was retrieved. The Magisk APK was then used to patch the image, and the resulting file was flashed to the appropriate partition.

The sequence of commands used during the rooting process is provided in Listing~\ref{lst:rooting-commands}.

\begin{lstlisting}[language=bash,caption={Rooting commands for device setup},label={lst:rooting-commands},numbers=left]
adb devices
adb reboot bootloader
fastboot flashing unlock
adb pull /sdcard/Download/OTA.zip
python payload_dumper.py payload.bin
fastboot flash boot_a magisk_patched-28100_4owcs.img
\end{lstlisting}

\subsubsection{ADB Setup and Execution Environment}

The ADB setup enabled detailed interaction between the computer and the rooted device, allowing the execution of custom shell scripts for tracing and Python scripts for detailed data parsing and cleaning. Issues regarding portability and trace events were tracked and resolved using a structured GitHub project setup.

This configuration ensured reliable kernel-level data collection, maintaining reproducibility, accuracy, and minimal system intrusion.

\subsubsection{Identifying Sensitive Database Files}

In order to monitor access to sensitive databases (such as \texttt{contacts2.db} or \texttt{mmssms.db}), each target file needed to be uniquely identified using its inode and device ID. The \texttt{stat} command was used to extract this metadata, which provided both the inode number and the major/minor device number of the filesystem hosting the file. An example command is shown in Listing~\ref{lst:db-stat}.

\begin{lstlisting}[language=sh,caption={Retrieving inode and device ID for a database file},label={lst:db-stat},numbers=left]
adb shell stat /data/data/com.android.providers.contacts/databases/contacts2.db
\end{lstlisting}

The output of this command includes the \texttt{Device}, \texttt{Inode}, and full path, which were stored as part of a JSON metadata mapping. These values were then used to match trace events against specific sensitive files during analysis.

\subsubsection{Device Node Mapping for Hardware Resources}

To associate trace events with hardware resources such as the camera, microphone, or NFC module, we identified the corresponding character device nodes exposed by the kernel. Each device node in \texttt{/dev} is linked to a major and minor number pair, which can be extracted from the \texttt{/sys/class/**/dev} entries. A loop was used to recursively enumerate device nodes and extract their metadata, as illustrated in Listing~\ref{lst:device-node-scan}.

\begin{lstlisting}[caption={Enumerating character and block devices with major:minor IDs},label={lst:device-node-scan},numbers=left]
adb shell
for f in $(find /sys/class/ -name dev); do
    echo "$f -> $(cat $f)"
done
\end{lstlisting}

Each output entry was parsed to associate paths like \texttt{/dev/video0} or \texttt{/dev/nq-nci} with their respective major:minor IDs. These values were encoded using the formula shown in Listing~\ref{lst:devt-calc}.

\begin{lstlisting}[caption={Encoding device number using major and minor},label={lst:devt-calc},numbers=none]
dev_t = (major << 20) | minor
\end{lstlisting}

This encoding was used in the trace parser to associate low-level device accesses with high-level categories such as camera or audio input.

\subsubsection{Automation and Metadata Serialization}

To automate both processes, a collaborator (Giannis Karyotakis) contributed Bash and Python scripts that programmatically retrieved and serialized this metadata into structured JSON files. These mappings were then used during the trace parsing phase to enrich low-level kernel events with high-level semantic labels.

This structured and collaborative approach enabled high-fidelity kernel tracing while minimizing manual overhead and potential for error.
An excerpt of the structured metadata format is shown in Listing~\ref{lst:json-metadata}, demonstrating how each sensitive resource is uniquely identified by a combination of its inode, major/minor device numbers, and a descriptive label.

\begin{lstlisting}[caption={Serialized JSON metadata for sensitive resource mapping},label={lst:json-metadata},numbers=left]
{
  "contacts": {
    "st_dev16": 65102,
    "st_dev32": 266338382,
    "major": 254,
    "minor": 78,
    "inode": 9253,
    "path": "/data/data/com.android.providers.contacts/databases/contacts2.db",
    "description": "Contacts database"
  }
}
\end{lstlisting}

\subsection{System Architecture and Data Flow}

The system is architected as a multi-layered pipeline for capturing, processing, and analysing kernel-level behavioural data on Android devices. Figure~\ref{fig:architecture} illustrates the overall architecture and the principal data flow across its components.

At a high level, the pipeline begins with a mobile-side tracing engine, which leverages configurable instrumentation via \texttt{kprobes} and declarative tracing policies. The engine is supported by a resource resolution layer that augments raw trace events with context such as inode paths, socket identifiers, and mapping metadata. This layer plays a critical role in enabling high-level semantic interpretation of low-level events. In particular, it facilitates the identification of accesses to sensitive device resources such as the camera or microphone, as well as interactions with privacy-critical application components, including contact lists, messaging services, and storage providers.

The collected data is stored temporarily on the device and later transferred to the host system for processing. There, a sequence of Python utilities and analysis notebooks is employed to parse, filter, flatten, and segment the traces. These components enable information flow tracking for specific applications and generate both static and interactive outputs.

Visualisation is handled through a modular dashboard consisting of a Flask-based backend and a D3.js-driven frontend. This dashboard supports dynamic filtering, event inspection, and behavioural summaries via timeline and statistical charts.

Each component of the system—ranging from mobile-side tracing and contextual enrichment, to host-side processing and web-based presentation—will be described in detail in the following sections, with direct reference to the layers depicted in Figure~\ref{fig:architecture}.
\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{architecture.png}
\caption{High-level modular architecture and data-flow pipeline of SliceDroid.}
\label{fig:architecture}
\end{figure}



\subsubsection{Codebase Structure}

The codebase is organised into clearly defined top-level components to support trace collection, processing, and interactive exploration. The main elements are outlined below:

\begin{description}
  \item[\texttt{scripts/}] Contains tracing and resource-mapping scripts. It includes configuration files for enabled events, kprobes, and process filters, helper scripts for resolving device and inode identifiers, as well as the App Mapper script responsible for generating the JSON mapping of Android package names to commercial application names.

  \item[\texttt{run\_slicedroid.py}] Entry point for running the customised SliceDroid tracer with the specified settings.

  \item[\texttt{data/}] Serves as the central storage for raw traces, identifier mappings, and processed outputs. It includes the \texttt{Exports/} subfolder, which holds cleaned trace exports and generated figures.

  \item[\texttt{webapp/}] Hosts the web-based visualisation tool, with a Flask backend and a Bootstrap/D3.js frontend for displaying behavioural timelines and analytics.
\end{description}

\subsubsection{Instrumentation Layer}

The instrumentation layer is responsible for capturing low-level system interactions occurring on the Android device. The initial implementation of the tracing subsystem was developed by Nikos Alexopoulos as part of the SliceDroid, and forms the foundational backbone of this thesis. This base layer leverages dynamic kernel probes (\texttt{kprobes}) and static \texttt{tracepoints} exposed via the \texttt{ftrace} interface, allowing efficient interception of system call and function-level activity in the kernel.

The original setup includes probes on core I/O functions such as \texttt{vfs\_read}, \\ \texttt{vfs\_write}, and \texttt{do\_vfs\_ioctl}, enabling access to internal kernel structures (e.g., \texttt{file}, \texttt{inode}, \texttt{super\_block}) and extraction of metadata such as device and inode identifiers, file types, and access credentials. In addition, Binder transactions are captured using the static tracepoints \texttt{binder\_transaction} and \texttt{binder\_transaction\_received}.

In the context of this thesis, we extended the instrumentation layer to include additional \texttt{kprobes} targeting network-related operations. Specifically, probes were added on functions such as \texttt{\_\_tcp\_sendmsg}, \texttt{udp\_sendmsg}, \texttt{inet\_sendmsg}, \texttt{sys\_sendto}, \texttt{sys\_bind}, and \texttt{tcp\_connect}, enabling the reconstruction of socket-level behaviors and outbound communication events. This augmentation allows for the detection of privacy-sensitive network transmissions and complements the I/O and IPC tracing pipeline with external data flow visibility.

An example of a \texttt{kprobe} used to trace write operations through the \texttt{vfs\_write} function is shown below:

\begin{lstlisting}[language=bash,caption={Example kprobe for vfs\_write in tracefs syntax}]
p:kprobes/write_probe vfs_write file=$arg1 buf=$arg2 count=$arg3
  inode=+64(+32($arg1)):u64
  k_dev=+76(+32($arg1)):u32
  s_dev=+16(+40(+32($arg1))):u32
  i_mode=+0(+32($arg1)):u16
  kuid=+4(+32($arg1)):u32
  kgid=+8(+32($arg1)):u32
  name=+0(+40(+24($arg1))):string
\end{lstlisting}

Instrumentation is activated through on-device \texttt{bash} scripts, which dynamically configure and manage the tracing session using declarative configuration files. These files specify the enabled probes, filter targets (e.g., process names, syscalls), and logging preferences. All events are timestamped with nanosecond precision to enable accurate temporal correlation during analysis.

This modular instrumentation layer is lightweight, compatible with existing Android kernels, and deployable without kernel recompilation or Android framework modifications. It provides the raw behavioral signal that drives the parsing, slicing, and behavior reconstruction pipeline described in the following sections.


\subsubsection{Resource Resolver Layer}

The \emph{Resource Resolver Layer} bridges the semantic gap between
raw kernel identifiers and human–readable resource categories.  It
accepts two heterogeneous streams that originate from the
Instrumentation Layer:

\begin{enumerate}
  \item \textbf{Special‐device nodes}\,: 32-bit packed
        \texttt{dev\_t} values (\texttt{k\_dev}) extracted from
        \texttt{vfs\_read}/\texttt{vfs\_write}/\texttt{ioctl} probes.
  \item \textbf{Regular files}\,: \texttt{(st\_dev,\;inode)} tuples
        identifying SQLite databases that hold privacy-critical data
        (\texttt{contacts2.db}, \texttt{mmssms.db}, \textit{etc.}).
\end{enumerate}

Its task is to emit a many-to-one mapping
\texttt{\{category $\rightarrow$ [identifiers]\}} where
\texttt{category}~$\in$~\{\textit{camera}, \textit{audio\_in},
\textit{bluetooth}, \textit{gnss}, \textit{nfc},
\textit{contacts}, \textit{sms}, \textit{calllog},
\textit{calendar}\}.
Down-stream modules can then reason about ``use camera’’ or ``read
contacts’’ instead of opaque major/minor numbers.

Algorithm~\ref{alg:resolver} captures the essence of the resolver logic
independently of the concrete implementation language.

\begin{algorithm}[H]
\footnotesize
\caption{Resolve low-level identifiers to high-level categories}
\label{alg:resolver}
\DontPrintSemicolon
\KwIn{$D$ : list of device entries $(\text{name},\ \text{rdev},\ \text{owner},\ \text{group})$\\
\phantom{\KwIn{}}$F$ : list of file entries $(\text{path},\ \text{st\_dev},\ \text{inode})$}
\KwOut{Dictionary $M$ : category $\rightarrow$ list of identifiers}
$M \leftarrow \{\}$
\BlankLine
\ForEach{$(name, rdev, owner, group) \in D$}{
    \uIf{$\texttt{camera} \in name$ \textbf{or} $owner = \texttt{camera}$}{
        $M[\text{camera}] \gets M[\text{camera}] \cup \{rdev\}$
    }
    \uElseIf{$name$ starts with \texttt{pcm} \textbf{and} ends with \texttt{c}}{
        $M[\text{audio\_in}] \gets M[\text{audio\_in}] \cup \{rdev\}$
    }
    \ElseIf{$\texttt{bluetooth} \in name$}{
        $M[\text{bluetooth}] \gets M[\text{bluetooth}] \cup \{rdev\}$
    }
    \ElseIf{$\texttt{nfc} \in name$}{
        $M[\text{nfc}] \gets M[\text{nfc}] \cup \{rdev\}$
    }
    \ElseIf{$\texttt{gps} \in name$ \textbf{or} $\texttt{gnss} \in name$}{
        $M[\text{gnss}] \gets M[\text{gnss}] \cup \{rdev\}$
    }
}
\BlankLine
\ForEach{$(path, dev, ino) \in F$}{
    \uIf{$\texttt{contacts} \in path$}{
        $M[\text{contacts}] \gets M[\text{contacts}] \cup \{(dev, ino)\}$
    }
    \uElseIf{$\texttt{mmssms} \in path$}{
        $M[\text{sms}] \gets M[\text{sms}] \cup \{(dev, ino)\}$
    }
    \uElseIf{$\texttt{calllog} \in path$}{
        $M[\text{calllog}] \gets M[\text{calllog}] \cup \{(dev, ino)\}$
    }
    \uElseIf{$\texttt{calendar} \in path$}{
        $M[\text{calendar}] \gets M[\text{calendar}] \cup \{(dev, ino)\}$
    }
}
\Return{$M$}
\end{algorithm}
\BlankLine
\BlankLine
In addition to these streams, a key contribution of this thesis within this layer is the development of a dedicated \textbf{App Mapper Module} to tackle a fundamental challenge in kernel-level tracing: the "semantic gap" between system identifiers and real-world applications.

The mapper bridges this gap by resolving cryptic Android package names (e.g., \texttt{com.facebook.orca}) into their recognizable commercial counterparts (e.g., \texttt{Messenger}). To achieve this, it connects to the target device via \textbf{ADB}, enumerates installed applications, and programmatically pulls each APK. It then uses the \textbf{\texttt{androguard}} library to perform a lightweight static analysis, extracting the application's public name from its metadata.

The resulting key-value pairs are serialized into a \textbf{JSON mapping file}. Downstream components, from the trace parser to the visualization dashboard, consume this file to automatically enrich the raw data. This process transforms obscure trace events into clear, human-readable insights, significantly enhancing the interpretability and practical value of the entire analysis pipeline (see Appendix~\ref{appendix:app-mapper-code} for implementation details).

\subsubsection{Parsing and Pre-Processing}
After the raw kernel traces were collected from the device, they were quickly pre-processed using a lightweight Python parser. Each trace line was split using regular expressions to extract the main header fields (task, PID, CPU, flags, timestamp, event name) and the detailed key-value pairs. Numerical fields were converted to plain decimal form, flags were normalized, and paths were cleaned of extra characters.

Next, a sequence of basic filters removed background noise: well-known system daemons were excluded, short-lived file descriptors were ignored, and redundant Binder transaction chatter was collapsed. Finally, the cleaned trace events were divided into overlapping windows to enable manageable and context-preserving analysis in the next steps. This simplified approach followed the same principles as in SliceDroid but was adapted for faster exploratory profiling.

\subsubsection{Slicing and Information-Flow Tracking}

For each window and seed PID $p$, we reconstruct per-process
information flows using the dual-pass IPC slicing algorithm adapted
from SliceDroid (Algorithms 1–2):

\begin{enumerate}
  \item \textbf{Forward slice (out-flows).}
        Scan events in chronological order; maintain a dynamic set
        $P$ of “reachable’’ PIDs (initially $\{p\}$).
        \emph{IPC $\rightarrow$} events add the destination PID to $P$;
        \emph{write/ioctl/net-send} events emitted by any
        $q\!\in\!P$ are recorded as outward dataflows.
  \item \textbf{Backward slice (in-flows).}
        Repeat in reverse time order; \emph{IPC~$\rightarrow$} adds
        the source PID, and \emph{read/net-recv} events supply the
        inbound dependencies.
\end{enumerate}

Each slice yields a directed, per-window causal graph
$G=(V,E)$ where
$V$ = PIDs and $E$ = \{read, write, ioctl, socket, binder\}.
Graphs are merged across consecutive windows via identical
transaction IDs (Binder) and socket tuples, producing a
whole-session trace of:

\[
  \text{API call} \;\xrightarrow{\;G\;}\;
  \Bigl\{\,
     \text{device nodes},\;
     \text{files},\;
     \text{sockets}
  \Bigr\}
\]

\noindent
The resulting flow descriptors are serialised to
\texttt{JSON/CSV} for downstream analytics and drive both the static
PDF plots and the interactive Flask–D3 dashboard.


\subsection{Data Visualization and User Interface Design}

The SliceDroid platform has been significantly extended into a fully-featured web application with an integrated dashboard, while maintaining its thoughtfully designed, step-by-step interface that guides analysts from initial trace file upload through to detailed security insights and forensics.

Figure~\ref{fig:home_screen} shows the home screen, which acts as the starting point for each analysis session. Users can upload a new raw \texttt{.trace} file by dragging it onto the upload area or selecting it manually. For convenience, the system also supports preloading the most recently used trace file, indicated as \texttt{trace.trace}, so that repeated uploads are not necessary during iterative investigations.
In parallel, the user can choose a target application from a list dynamically populated with the apps currently installed on the connected device (e.g., Messenger, Signal, Telegram, Termux).
 Additional process ID and device filters refine the scope even further before launching the analysis.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{home_screen.png}
\caption{Home screen with options for uploading a new trace file, preloading the last trace, and selecting a target application for focused security analysis.}
\label{fig:home_screen}
\end{figure}

After selecting the trace and target application, the analyst transitions to the interactive event timeline (Figure~\ref{fig:event_timeline}). This timeline provides a clear, category-separated view of syscall activity over time, grouped into logical classes such as \texttt{read}, \texttt{write}, \texttt{ioctl}, Binder events, and network operations. The timeline supports zooming, panning, and detailed inspection via hover tooltips, allowing investigators to pinpoint unusual spikes, suspicious sequences, or gaps in expected process behaviour.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{system_events_timeline.png}
\caption{Interactive event timeline showing syscall activity split into categories with intuitive zoom and hover inspection tools.}
\label{fig:event_timeline}
\end{figure}

Complementary to the timeline is the Device and Event Statistics panel (Figure~\ref{fig:device_event_statistics}). On the left, a pie chart and table break down which hardware devices were accessed during the trace period, highlighting the top devices by event count. On the right, the system shows the proportion of syscall event types (e.g., \texttt{ioctl\_probe}, \texttt{read\_probe}), their absolute counts, and percentage shares. This dual view helps analysts understand which resources and syscall classes dominate the workload, which is often critical for detecting outlier device usage or unexpected access patterns.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{device_event_statistics.png}
\caption{Device and event statistics: left pane shows device usage distribution and top devices; right pane displays breakdown of syscall event types.}
\label{fig:device_event_statistics}
\end{figure}

Figure~\ref{fig:analytics_panel} presents the Advanced Analytics module. This section displays high-level metrics including total event count, unique processes and devices, trace duration, and calculated event throughput in events per second. Below these KPIs, the Behaviour Timeline plots activity windows for categories like Camera, TCP, Bluetooth, SMS, and other sensitive subsystems. This windowed view helps correlate spikes in device behaviour with specific time windows, enabling fine-grained behavioural profiling.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{analytics_panel.png}
\caption{Advanced Analytics: high-level metrics and the Behaviour Timeline, offering windowed insight into sensitive categories such as network and peripheral usage.}
\label{fig:analytics_panel}
\end{figure}

For focused inspection of network behaviour, the Network Analysis module (Figure~\ref{fig:network_view}) visualises the distribution of TCP and UDP events, socket operations, and the protocols in use. A graph-based Communication Flow diagram depicts the relationships between processes and external endpoints. Such visual context allows the investigator to detect unexpected data transfers or suspicious inter-process communication pathways.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{network_view.png}
\caption{Network Analysis: Communication Flow diagram, protocol distribution pie chart, and connection statistics for tracking network behaviour and potential exfiltration vectors.}
\label{fig:network_view}
\end{figure}

Process genealogy is equally crucial. Figure~\ref{fig:process_tree} illustrates how the system reconstructs the parent-child process tree, showing process activity summaries including PIDs, event counts, and suspicious patterns (highlighted below the tree). Here, anomalies such as excessive file accesses or unexpected forks can be quickly identified and traced back to their origin.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{process_tree.png}
\caption{Process Analysis: dynamic genealogy tree with activity summary and detected suspicious patterns, such as high file access counts.}
\label{fig:process_tree}
\end{figure}

Finally, Figure~\ref{fig:security_overview} shows the dashboard’s integrated security summary. This view aggregates risk scores, highlights privilege escalation attempts, debugging traces, or policy violations, and provides contextual recommendations for remediation. By centralising these indicators, analysts can prioritise threats and document findings more effectively.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{security_overview.png}
\caption{Security Overview: centralised display of detected risks, privilege escalation attempts, and recommended actions for the analyst.}
\label{fig:security_overview}
\end{figure}

In summary, the combined views — including the timeline, device and event statistics, advanced analytics, network and process modules, and security overlays — converge in a comprehensive summary dashboard (Figure~\ref{fig:summary_dashboard}). This final snapshot condenses category distribution, TCP state transitions, top device usage, and most active processes into a single, intuitive screen, offering a clear, actionable overview for immediate security insight and reporting.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{security_overview-2.png.png}
\caption{Comprehensive Summary Dashboard: unified visual of event categories, TCP states, device usage, and active process distribution for rapid situational awareness.}
\label{fig:summary_dashboard}
\end{figure}

Technically, all dynamic charts are rendered using \texttt{D3.js}, and the responsive UI is built with \texttt{Bootstrap}. A collapsible sidebar, integrated help tooltips, and live system health checks ensure usability and reliability throughout long-duration trace analysis sessions.

\subsubsection{Pipeline Summary}

To close this architecture chapter, Figure \ref{fig:pipeline} condenses the entire workflow into eight blocks: configuration and probe activation, low-overhead collection via \texttt{tracefs}, host-side parsing, cleaning, IPC slicing, export, a Flask API, and finally a D3.js dashboard.  Each block is self-contained, so downstream components can be swapped without touching the upstream instrumentation layer.

\begin{figure}[H]
\centering
\resizebox{\columnwidth}{!}{%
\begin{tikzpicture}[
  font=\sffamily\small,
  box/.style={
    rectangle, rounded corners=3pt,
    draw=black!65, very thick,
    fill=gray!20,
    text width=3cm, align=center,
    minimum height=1.0cm},
  arrow/.style={-{Latex[length=3mm,width=2mm]}, thick},
  node distance=1.3cm and 0.8cm]
% first row
\node[box] (cfg)   {\texttt{config\_files}\\\texttt{+ scripts}};
\node[box,right=of cfg]   (raw)   {raw trace\\};
\node[box,right=of raw]   (parse) {parsing};
\node[box,right=of parse] (clean) {cleaning\\\& indexing};
% second row
\node[box,below=1.1cm of clean] (slice) {slicing};
\node[box,left=of slice]        (exp)   {JSON / CSV\\export};
\node[box,left=of exp]          (api)   {Flask API};
\node[box,left=of api]          (viz)   {D3.js\\visualisation};
% arrows
\path[arrow]
  (cfg) edge (raw)
  (raw) edge (parse)
  (parse) edge (clean)
  (clean) edge[below] (slice)
  (slice) edge (exp)
  (exp) edge (api)
  (api) edge (viz);
\end{tikzpicture}%
}
\caption{End-to-end data flow from probe configuration to interactive analytics.}
\label{fig:pipeline}
\end{figure}

\subsection{Workload Design and Usage Scenarios}

To capture meaningful behavioural variations and to systematically compare how each application responds under distinct runtime conditions, dynamic kernel-level tracing was organised into four carefully defined usage scenarios per target app. This multi-scenario design enables direct cross-scenario comparison, revealing differences in resource usage, inter-process communication (IPC), and network interactions when permissions or user activity levels vary.

\begin{enumerate}[label=\roman*.]
  \item \textbf{Full Permissions Scenario:} The application was run with all permissions granted, allowing observation of its maximum functional scope. In this mode, a consistent sequence of actions was performed: sending two text messages, recording a short voice message (approximately 5 seconds long), and capturing a photo using the in-app camera. This interaction pattern ensures coverage of typical real-world usage and tests multiple privacy-sensitive features simultaneously. The full permissions scenario serves as a baseline to compare against restricted and passive states, helping isolate which activities depend on specific permissions.

  \item \textbf{Restricted Permissions Scenario:} Selected sensitive permissions (e.g., location, microphone, or contacts) were deliberately disabled through the Android settings. This condition was designed to examine how the application adapts when permission-dependent features are blocked—whether it attempts repeated access, triggers fallback code, or suppresses functionality altogether. Comparing this scenario to the full permissions case highlights how gracefully or aggressively each app handles denied permissions.

  \item \textbf{Background Passive Scenario:} The app was left running in the background with normal permissions but without user interaction. This scenario was included to detect silent background behaviours such as periodic syncs, push notification handling, or unexpected network calls that occur independently of user input. Analysing this passive state alongside active usage reveals latent behaviours that could impact privacy or battery consumption.

  \item \textbf{Active Foreground Scenario:} The app was actively used for normal tasks such as messaging, media sharing, and voice or video calls where applicable. This scenario represents the peak operational state with frequent user actions, providing a reference for typical real-world usage patterns. Comparing it with the passive and restricted runs helps pinpoint which kernel-level events are triggered exclusively by user-initiated activity versus background processes.
\end{enumerate}

Each scenario execution lasted approximately 30 seconds. This duration was strategically chosen as a pragmatic balance: it is long enough to capture the complete sequence of system calls for common user actions (e.g., sending a message or capturing a photo), yet short enough to minimise noise from unrelated background processes and keep the resulting trace files to a manageable size for analysis. Each run was repeated multiple times to enhance statistical reliability and minimise outlier effects. The scenarios were systematically executed in a consistent sequence—starting from passive, followed by restricted, then full permissions, and concluding with active usage—to ensure stable device conditions and to avoid cross-contamination of residual states.

By applying this structured workload design, the resulting traces enable detailed side-by-side comparisons. This makes it possible to clearly identify behavioural deviations across permission settings and activity states, providing deeper insights into each application's runtime privacy implications and resource footprint.


% --------------------------------------------------
%  Results
% --------------------------------------------------
\chapter{Results}

\section{Static Analysis Results}

This chapter presents a detailed \emph{static} security appraisal of three widely used instant messaging clients—\textit{Signal}, \textit{Telegram}, and \textit{Meta Messenger}—based on production-signed APK packages acquired directly from physical Android devices using the ADB. Specifically, each APK was retrieved via the following commands:

First, all installed packages on the device were enumerated with:
\begin{lstlisting}[language=bash]
adb shell pm list packages
\end{lstlisting}

Next, the full installation path of a selected package was queried:
\begin{lstlisting}[language=bash]
adb shell pm path <package_name>
\end{lstlisting}

Finally, the APK was pulled to the local workstation:
\begin{lstlisting}[language=bash]
adb pull /data/app/<apk_path> ./
\end{lstlisting}

The subsequent static evaluation utilises tools including \textsc{MobSF}, \textsc{Androguard}, and \textsc{APKID} to thoroughly dissect manifest configurations, bytecode payloads, native binaries, and embedded resources.

\subsection{Scope and Dataset Footprint}

The static security review was systematically conducted in five incremental stages to ensure breadth and depth of inspection.

\textbf{Manifest Analysis} scrutinised high-risk configuration flags—most notably the \lstinline{allowBackup} attribute, the exposure of components via exported activities and services, and the full set of declared Android permissions.

\textbf{Bytecode Inspection} involved decompiling and scanning the compiled \texttt{.dex} code, pinpointing insecure coding constructs, potential logic flaws, and signatures of known vulnerabilities.

\textbf{Native Library Hardening} assessed the integrity of any packaged native binaries, verifying the presence of critical exploit mitigations such as Non-Executable Stack (NX), Position-Independent Executable (PIE), Stack Canaries, RELRO (Relocation Read-Only), and \textsc{FORTIFY} source hardening.

\textbf{Secret Scanning} leveraged entropy-based heuristics to detect embedded sensitive data, such as API tokens, secret keys, and credentials inadvertently hard-coded in resources or source strings.

Finally, \textbf{Anti-Analysis and Obfuscation Review} catalogued defensive mechanisms against dynamic or static reverse engineering, including anti-debugging checks, emulator detection routines, and custom obfuscation artefacts.


The artifacts from this multi-phase assessment were compiled as succinct CSV exports (each under 100 kB) and comprehensive PDF reports (typically between 100 and 200 kB).

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Application} & \textbf{CSV size (kB)} & \textbf{PDF size (kB)} \\
\hline
Signal & 50 & 120 \\
Messenger & 80 & 180 \\
Telegram & 45 & 110 \\
\hline
\end{tabular}
\caption{Approximate sizes of static analysis output files}
\label{tab:static-sizes}
\end{table}

\subsection{Detailed Application Findings}
The following pages present the most relevant static observations for the three
evaluated messaging apps.  We begin with basic APK metadata, continue with a
high-level view of exposed components, and close with the severity distribution
reported by \textsc{MobSF}.  The discussion is intentionally brief and focuses on
facts that are likely to affect security posture.

\subsubsection{APK Metadata Overview}
All three applications already target Android 14 (API 34) or newer, with
\textbf{Messenger} going a step further to API 35—an advantage for users on the
bleeding-edge OS track.
The declared minimum SDK, however, differs noticeably:
\textbf{Signal} still supports devices back to API 21 (Android 5.0),
\textbf{Telegram} to API 23 (Android 6.0), whereas \textbf{Messenger} drops
legacy versions entirely by setting its floor at API 28 (Android 9).
Shrinking that compatibility window simplifies maintenance and removes
long-standing platform bugs, though at the expense of excluding pre-Pie users.

Package size presents an intriguing anomaly.
Although \textbf{Messenger} contains by far the most extensive component
inventory—nearly five-hundred activities and over one-hundred services—its APK
is only \SI{66}{MB}, markedly smaller than Signal’s \SI{86}{MB}.
Differences in compression techniques, split-APK delivery for native libraries,
and stronger reliance on on-demand feature modules likely account for part of
this gap.

\begin{table}[htbp]
  \centering
  \caption{Key APK Metadata (June 2025)}
  \label{tab:metadata}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{App} & \textbf{Min SDK} & \textbf{Target SDK} & \textbf{APK Size} \\ \hline
    Signal    & 21 & 34 & 85.6\,MB \\ \hline
    Telegram  & 23 & 34 & 43.2\,MB \\ \hline
    Messenger & 28 & 35 & 66.3\,MB \\ \hline
  \end{tabular}
\end{table}
\subsubsection{Static Findings Severity Overview}
MobSF’s aggregate grading shows that all three applications sit in the same “B-range,” yet their internal risk profiles diverge markedly. \textbf{Signal} records the fewest high-severity issues (three), suggesting a comparatively tight baseline configuration, although a non-negligible volume of medium findings (forty-three) still demands sustained remediation effort. \textbf{Telegram} doubles the high-risk tally and edges ahead in medium alerts, indicating broader exposure despite its leaner component graph. \textbf{Messenger} stands out: ten high-severity items and almost a hundred medium-level flags underscore the operational complexity already noted in its manifest. While the platform does earn one additional “Secure” mark, the ratio of critical to informational findings highlights a heavier security debt that subsequent sections will examine in detail.

\begin{table}[htbp]
  \centering
  \caption{Findings Severity (MobSF)}
  \label{tab:findings-severity}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Severity Level} & \textbf{Signal} & \textbf{Telegram} & \textbf{Messenger} \\ \hline
    High & 3 & 5 & 10 \\ \hline
    Medium & 43 & 47 & 98 \\ \hline
    Info & 3 & 4 & 3 \\ \hline
    Secure & 3 & 3 & 4 \\ \hline
    Hotspot & 2 & 1 & 1 \\ \hline
  \end{tabular}
\end{table}


\subsubsection{Component Analysis}

Among the three applications, \textbf{Messenger} exhibits by far
 the greatest architectural complexity, bundling close to five
  hundred activities together with more than one hundred background
  services; this breadth of functionality inevitably widens the attack
  surface and imposes a substantial testing burden. By contrast,
   \textbf{Telegram} maintains the smallest public activity surface yet
   still exposes fifteen services—roughly twice the number found in Signal—so
    careful permission-guarding is essential to mitigate potential
     component-hijacking risks. \textbf{Signal}, meanwhile, publishes
      no content providers at all, thereby curtailing direct inter-application
      data exchange, although its nineteen exported activities remain non-trivial
      and should be reviewed on a recurring basis.

\begin{table}[htbp]
  \centering
  \caption{Detailed Comparison of App Components}
  \label{tab:app-components-horizontal}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Component Type} & \textbf{Signal} & \textbf{Telegram} & \textbf{Messenger} \\ \hline
    Activities & 89 & 16 & 496 \\ \hline
    Services & 25 & 28 & 114 \\ \hline
    Receivers & 30 & 25 & 77 \\ \hline

    Exported Activities & 19 & 14 & 12 \\ \hline
    Exported Services & 7 & 15 & 25 \\ \hline
    Exported Receivers & 4 & 3 & 14 \\ \hline
    Exported Providers & 0 & 1 & 6 \\ \hline
  \end{tabular}
\end{table}



\subsubsection{Manifest posture}
As shown in \autoref{tab:manifest-severity}, the MobSF scan exposes three distinct risk profiles.
Telegram leads with \emph{two} \emph{High}-severity findings and thirty-six warnings, signalling several manifest settings that could be exploited if left unpatched.
Signal reports a single \emph{High} issue plus thirty-two warnings—evidence of a somewhat tighter, though still imperfect, configuration.
Messenger has no high-severity items, yet its eighty-six warnings reveal a “many-small” pattern of misconfigurations that can accumulate technical debt, especially given Meta’s rapid release cadence.

\begin{table}[htbp]
  \centering
  \caption{Manifest Issues by Severity (MobSF)}
  \label{tab:manifest-severity}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Severity Level} & \textbf{Signal} & \textbf{Telegram} & \textbf{Messenger} \\ \hline
    High      & 1  & 2  & 0  \\ \hline
    Warning   & 32 & 36 & 86 \\ \hline
    Info      & 0  & 0  & 0  \\ \hline
  \end{tabular}
\end{table}

Turning to the individual flags in \autoref{tab:critical-flags}, all three applications keep \\
 \texttt{allowBackup=true}, meaning a device in developer mode can exfiltrate private app data unless users disable OEM backup routes. Only Telegram and Messenger permit clear-text HTTP traffic globally—a policy that undermines transport-layer confidentiality and should be restricted to explicit, whitelisted domains. Finally, Messenger presents the largest externally visible surface with forty-eight exported components, followed by Telegram at thirty-three and Signal at nineteen; every exported entry must be permission-guarded or otherwise verified to avoid component-hijacking attacks.
\begin{table}[htbp]
  \centering
  \caption{Critical Manifest Flags}
  \label{tab:critical-flags}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Flag} & \textbf{Signal} & \textbf{Telegram} & \textbf{Messenger} \\ \hline
    \texttt{allowBackup}        & \cmark & \cmark & \cmark \\ \hline
    \texttt{cleartextTraffic}   & —      & \cmark & \cmark \\ \hline
    \texttt{exportedComponents} & 19     & 33     & 48     \\ \hline
  \end{tabular}
\end{table}



\subsubsection{Permission context}
Requesting “dangerous’’ permissions is—at least to a point—inevitable for
modern IM clients: contact synchronisation (\texttt{READ\_CONTACTS},
\texttt{WRITE\_CONTACTS}) underpins address-book integration, storage
permissions allow media exchange, while microphone, camera, and location
access enable voice messages, video calls, and live-location sharing.  These
rights, however, also classify as \emph{high-risk vectors} because they unlock
direct access to PII, sensors, and the filesystem.  Notably, \textbf{Telegram}
and \textbf{Messenger} extend their reach with system-level privileges such as
\texttt{CALL\_PHONE}, \texttt{SYSTEM\_ALERT\_WINDOW}, and full account
management—features that power in-app calling, chat-head overlays, or multiple
account workflows, but simultaneously broaden the abuse surface (e.g.\ overlay
phishing or component hijacking).  \textbf{Signal}, by contrast, adopts a
\emph{minimal-necessary} stance, omitting phone-call control, overlay windows,
background location, calendar access, and package-installation rights.  This
leaner footprint limits the attack surface without materially impairing core
functionality, illustrating a tighter alignment with the principle of least
privilege.
\begin{table}[htbp]
  \centering
  \caption{Differential Dangerous Permissions (Top 10)}
  \label{tab:differential-permissions}
  \setlength{\tabcolsep}{6pt}
  \begin{tabular}{@{}lccc@{}}
    \toprule
    \textbf{Permission}
        & \textbf{Signal}
        & \textbf{Telegram}
        & \textbf{Messenger} \\ \midrule
    \texttt{USE\_CREDENTIALS}           & \cmark & —      & — \\
    \texttt{MANAGE\_ACCOUNTS}           & —      & \cmark & \cmark \\
    \texttt{SYSTEM\_ALERT\_WINDOW}      & —      & \cmark & \cmark \\
    \texttt{CALL\_PHONE}                & —      & \cmark & \cmark \\
    \texttt{REQUEST\_INSTALL\_PACKAGES} & —      & \cmark & — \\
    \texttt{ACCESS\_BACKGROUND\_LOCATION} & —    & \cmark & — \\
    \texttt{READ\_CALL\_LOG}            & —      & \cmark & — \\
    \texttt{READ\_CALENDAR}             & —      & —      & \cmark \\
    \texttt{WRITE\_CALENDAR}            & —      & —      & \cmark \\
    \texttt{BLUETOOTH\_CONNECT}         & —      & \cmark & \cmark \\ \bottomrule
  \end{tabular}
\end{table}

\paragraph{Bytecode‐level exposure.}%
Static inspection of the \texttt{.dex} payloads (\autoref{tab:code-vuln}) confirms
a common baseline of cryptographic missteps—most notably the continued use of
AES in CBC mode without accompanying integrity checks.
Both \textbf{Messenger} and \textbf{Telegram} further embed debug-enabled
\texttt{WebViews}, a design choice that simplifies troubleshooting but risks
remote code–execution should those views become reachable at run time.
\textbf{Signal} avoids that trap yet implements a permissive “trust-all’’ SSL
fallback, undermining certificate validation in edge cases. World-writable
artefacts are exclusive to Messenger, compounding the impact of its larger
secret corpus.

All three binaries leak strings that
score above the Shannon-entropy threshold typically used to flag embedded keys
or tokens. Although some hits are likely innocuous (e.g.\ public RSA
moduli or test vectors), the order-of-magnitude difference is revealing:
\textbf{Signal} contains roughly \num{492} such literals, \textbf{Messenger}
about \num{372}, whereas \textbf{Telegram} exposes only \num{23}. A dense
concentration of opaque byte arrays suggests in-app storage of encryption keys,
API credentials, or feature flags that could be harvested by an attacker with
static-analysis skills. Even if individual values prove non-sensitive, their
sheer volume complicates code review and widens the search space for
vulnerability researchers.

Taken together, while all three projects inherit medium-tier warnings—raw SQL
strings, legacy digests, and non-cryptographic PRNGs—the distribution of
high-severity items continues to underscore a stricter secure-coding discipline
in Signal when compared to its competitors, albeit with the caveat of its
unusually large pool of embedded high-entropy data.

\begin{table}[htbp]
  \centering
  \caption{Comparative Matrix of Code--Level Vulnerabilities}
  \label{tab:code-vuln}
  \begin{tabular}{|p{6.1cm}|c|c|c|}
    \hline
    \textbf{Issue} & \textbf{Messenger} & \textbf{Telegram} & \textbf{Signal} \\ \hline
    High-severity findings              & 4           & 5           & 3           \\ \hline
    Remote-debuggable \texttt{WebView}  & \cmark      & \cmark      & \xmark      \\ \hline
    AES--CBC without integrity          & \cmark      & \cmark      & \cmark      \\ \hline
    Trust-all SSL trust manager         & \xmark      & \xmark      & \cmark      \\ \hline
    World-writable/readable files       & \cmark      & \xmark      & \xmark      \\ \hline
    Raw SQL injection risks             & Warning     & Warning     & Warning     \\ \hline
    Weak digests (MD5, SHA-1)           & Warning     & Warning     & Warning     \\ \hline
    Insecure PRNG usage                 & Warning     & Warning     & Warning     \\ \hline
    Hard-coded high-entropy secrets     & 372         & 23          & 492         \\ \hline
  \end{tabular}
\end{table}

\paragraph{Third-party telemetry \emph{vs.} privileged scope.}%
\label{sec:trackers-vs-perms}

\autoref{tab:trackers} shows that only \textbf{Messenger} bundles external
analytics or debugging SDKs (\emph{Flipper}, Google Analytics, Mapbox).  While
these libraries facilitate crash reporting and in-app mapping, they also widen
the app’s network footprint and introduce code that is not fully controlled by
the first-party vendor.  \textbf{Telegram} and \textbf{Signal}, by contrast,
ship with no declared tracker packages, matching their privacy-first messaging.

Risk, however, is not dictated by trackers alone.  \autoref{tab:perm-malware}
intersects each manifest with a canonical set of 25 Android permissions that
mobile-malware signatures most frequently abuse (compiled from Koodous and
VirusTotal rule bases).  Telegram requests \(18\!/25\) of these privileges,
slightly more than Messenger (\(16\!/25\)) and clearly above Signal
(\(15\!/25\)).  Many of the flagged permissions (\texttt{CAMERA},
\texttt{RECORD\_AUDIO}, fine location) are legitimate for a modern messaging
suite; nonetheless, they enlarge the attack surface an adversary could exploit
after a successful code-execution bug.  Signal therefore retains the leanest
privilege envelope while also avoiding embedded trackers.

\begin{table}[htbp]
  \centering
  \caption{Declared third-party tracker SDKs}
  \label{tab:trackers}
  \begin{tabular}{|l|p{7cm}|}
    \hline
    \textbf{App} & \textbf{Embedded SDKs detected} \\ \hline
    Messenger & Facebook Flipper, Google Analytics, Mapbox \\ \hline
    Telegram  & — \\ \hline
    Signal    & — \\ \hline
  \end{tabular}
\end{table}

\begin{table}[htbp]
  \centering
  \caption{Overlap with 25 malware-associated permissions}
  \label{tab:perm-malware}
  \begin{tabular}{|l|c|}
    \hline
    \textbf{App} & \textbf{Dangerous permissions requested} \\ \hline
    Signal    & 15\,/\,25 \\ \hline
    Telegram  & 18\,/\,25 \\ \hline
    Messenger & 16\,/\,25 \\ \hline
  \end{tabular}
\end{table}

%------------------------------------------------
\paragraph{Firebase back-end exposure.}

Messenger diverges architecturally from its rivals: instead of relying on third-party back-ends it maintains a proprietary service mesh—historically rooted in custom XMPP extensions and, more recently, a gRPC-based “MqttLite” transport—so no Firebase endpoints appear in the binary.
Static string inspection, on the other hand, reveals hard-coded Firebase Realtime Database URLs in both Signal and Telegram. MobSF flags these only as \textit{info} because the associated Remote-Config queries are refused (HTTP 4/403), implying that anonymous feature-flag pulls are disabled. That safeguard hinges on server-side rules: if at any point permissive read/write ACLs are introduced—intentionally or by accident—the same endpoints could expose chat metadata or configuration secrets and escalate from “low noise” to a critical data-leak vector.

\subsection{Cross-Application Comparative Synthesis}
\label{sec:comparative-synthesis}

Static inspection assigns all three apps a \emph{B-tier} MobSF grade, yet the
underlying risk landscape diverges sharply.  \textbf{Messenger} emerges as the
most exposed candidate: clear-text traffic remains enabled, three telemetry
SDKs are bundled, and {\small 372} hard-coded secrets coexist with four
high-severity code findings.  \textbf{Telegram} fares marginally better—no
trackers and only 23 secrets—but it still requests the widest set of
malware-aligned permissions and carries five top-rank issues.  \textbf{Signal}
presents the leanest attack surface overall (no trackers, strict permission
profile), although its secret sprawl (\textasciitilde500 literals) and a
``trust-all'' SSL fallback warrant immediate attention.

\begin{table}[htbp]
  \centering
  \caption{Aggregate static-risk indicators.}
  \label{tab:risk-matrix}
  \begin{tabular}{|l|c|c|c|c|}
    \hline
    \textbf{App} & \textbf{MobSF Score} & \textbf{High} & \textbf{Secrets} & \textbf{Trackers} \\ \hline
    Messenger   & 48 (B) & 4 & 372 & 3 \\ \hline
    Telegram    & 49 (B) & 5 &  23 & 0 \\ \hline
    Signal      & 51 (B) & 3 & 492 & 0 \\ \hline
  \end{tabular}
\end{table}

Brand prominence on its own is no proxy for security maturity. At the same
time, code-base size and the age of the original release carry
weight: the larger and older an application, the more legacy modules and
technical debt it is likely to accumulate. Messenger—by far the heaviest and
oldest code-base in the set—consequently lags behind Telegram and the leaner,
newer Signal in several hardening metrics. Regardless of pedigree, however,
all three projects need continuous dynamic testing and refactoring to curb the
security drag that inevitably accompanies growth over time.

% ------------------------------------------


\section{Dynamic Analysis Results}
\subsection{Scope and Dataset Overview}

The dynamic analysis was systematically conducted to capture runtime behaviour
under the exact usage scenarios previously defined and executed in Section~4.3.4
\textit{Workload Design and Usage Scenarios}, using the selected messaging applications.
Each application was exercised in a controlled environment for approximately $30 \pm 1$
seconds per run, under four distinct operational modes: running in the background with full
operational permissions (\texttt{full\_background}), actively used in the foreground with full
permissions (\texttt{full\_foreground}), background execution with minimal resource activity
(\texttt{none\_background}), and foreground usage with reduced permissions (\texttt{none\_foreground}).
This workload configuration ensures behavioural consistency and repeatability across all test runs.
The resulting dataset comprises twelve trace files, each clearly named to encode the specific
application, scenario, and recording duration, providing full traceability and alignment with
the workload structure. Observed file sizes demonstrate an expected trend: foreground traces
under full permissions exhibit significantly larger footprints due to richer event flows from
user interactions and multimedia activities, while background and constrained scenarios yield
notably smaller trace volumes, reflecting lower runtime resource engagement.For example, the
trace for full foreground usage is up to 117~KB, compared to 16~KB for a none background case.
This structured dataset reflects the defined workload scenarios and provides a reliable basis
for comparing application behaviour, resource usage, and runtime characteristics under consistent
operating conditions. Notably, Signal consistently generates a smaller trace size than the other
applications in the foreground scenarios, which may indicate more minimalistic runtime behaviour
and stricter resource handling, in line with its lean and security-focused design previously
highlighted in the static analysis. This aspect will be further examined in the following sections,
where dynamic and static findings are jointly discussed.



\begin{table}[h!]
    \centering
    \caption{Grouped Overview of Trace Durations and File Sizes}
    \label{tab:dynamic_traces_grouped}
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Scenario Type} & \textbf{Context} & \textbf{Application} & \textbf{Duration (sec)} & \textbf{Size (KB)} \\
        \hline
        \multirow{6}{*}{Full}
        & \multirow{3}{*}{Background} & Messenger & 30.01 & 15.286 \\
        & & Signal & 29.57 & 15.155 \\
        & & Telegram & 29.83 & 15.670 \\
        & \multirow{3}{*}{Foreground} & Messenger & 30.17 & 117.109 \\
        & & Signal & 29.02 & 87.952 \\
        & & Telegram & 29.52 & 115.274 \\
        \hline
        \multirow{6}{*}{None}
        & \multirow{3}{*}{Background} & Messenger & 29.00 & 16.319 \\
        & & Signal & 29.46 & 16.376 \\
        & & Telegram & 30.39 & 16.547 \\
        & \multirow{3}{*}{Foreground} & Messenger & 30.35 & 72.231 \\
        & & Signal & 30.46 & 66.798 \\
        & & Telegram & 30.19 & 75.101 \\
        \hline
    \end{tabular}
\end{table}


\subsection{Statistical Summaries}

\subsubsection{Messenger Foreground Runtime Behaviour}

This section provides a concise descriptive snapshot of Messenger when running under typical user-driven interaction. As outlined in the \textit{Workload Design and Usage Scenarios}, the app was actively used in the foreground for sending text messages, recording a short voice clip, and capturing an image using the in-app camera. This representative workload was chosen as it reflects everyday usage, maximising feature invocation and generating diverse runtime events for meaningful analysis.

During this active usage interval of approximately $30$ seconds, a total of $557,770$ events were recorded, yielding an average throughput of about $18,512$ events per second. This high event density highlights Messenger’s intensive interaction patterns and concurrent background tasks typical of a realistic foreground session. The main runtime statistics summarised in Table~\ref{tab:messenger_key_stats} show that over a thousand processes were spawned, with a notable volume of file operations and IPC calls.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Messenger}
    \label{tab:messenger_key_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 30.17 sec \\
        Total Events & 557,770 \\
        Events per Second & 18,512 \\
        Unique Processes & 1,184 \\
        Active Processes & 218 \\
        File Operations & 410,707 \\
        IPC Events & 85,836 \\
        Notable Anomalies & 27 distinctive patterns \\
        Read/Write Ratio & 1.73 \\
        Most Accessed File Type & .db (7,693 times) \\
        \hline
    \end{tabular}
\end{table}

As shown, file operations dominate with over $410,000$ I/O calls, while inter-process communication contributes another $85,836$ events. The so-called \textit{distinctive patterns} in Table~\ref{tab:messenger_key_stats} refer to behavioural outliers, for example when an otherwise idle process suddenly performs an unusually high number of writes; these are not inherently malicious but can serve as an early hint for deeper inspection.

In terms of network behaviour and event type proportions, the \texttt{ioctl} category accounts for nearly half of all recorded calls, followed by \texttt{binder}, \texttt{read}, and \texttt{write} operations. Messenger also generates steady TCP traffic with a small number of UDP packets, transferring around 3.48 MB over TCP, alongside significant local UNIX datagram exchanges that reflect intensive intra-app service communication.

\begin{table}[H]
    \centering
    \caption{Network and Event Category Breakdown for Messenger}
    \label{tab:messenger_network_category}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Network Metric} & \textbf{Value} \\
        \hline
        TCP Events & 750 \\
        UDP Events & 2 \\
        Total TCP Data & 3.48 MB (0.3 MB sent, 3.16 MB received) \\
        UNIX Datagram Traffic & 2.44 MB sent, 48.2 MB received \\
        Unique Protocols & 4 \\
        Unique Connections & 2 \\
        \hline
        \textbf{Event Category} & \textbf{Proportion} \\
        \hline
        ioctl & 46.6\% \\
        binder & 18.5\% \\
        read & 18.1\% \\
        write & 10.5\% \\
        network & 6.3\% \\
        \hline
    \end{tabular}
\end{table}

Taken together, these figures confirm Messenger’s reliance on high-volume local storage, inter-process orchestration, and steady external connectivity during realistic usage—offering a robust baseline for comparing runtime patterns under constrained or passive states in subsequent sections.

\subsubsection{Messenger Background Runtime Behaviour}

When Messenger was left running in the background without direct user interaction, the captured trace covered a comparable window of about 30 seconds and produced a total of 38,965 events. This results in a much lower average throughput of approximately 1,300 events per second—significantly reduced compared to the 18,512 events per second observed during active usage.

From a process perspective, only 42 processes remained active in the background compared to 218 during the foreground session, which is entirely expected given the absence of active user interaction and the reduced need for real-time service coordination. File operations continued to dominate system calls, with 38,955 I/O events logged. The read/write ratio increased to 1.50, indicating a clear preference for read operations over writes—typical of periodic local state checks or passive data syncing rather than active message composition or media uploads. Database files (\texttt{.db}) remained the most accessed type but were triggered just 2,284 times, confirming limited storage engagement.

Regarding IPC, no explicit inter-process communication events were detected during this idle phase, suggesting that Messenger’s background services rely mostly on persistent resident processes rather than dynamic component interaction. Nonetheless, 8 distinctive patterns were still flagged, representing short bursts where isolated processes performed unusual spikes of read or ioctl calls—these do not indicate malicious behaviour but highlight passive checks or background sync routines.

Network activity in the background was minimal: only 8 TCP events and 2 UDP packets were detected, transferring less than 0.01 MB in total. This aligns with lightweight push notification checks or silent polling for updates—behaviour that is typical for messaging apps that need to remain responsive while conserving bandwidth and battery.

Overall, Messenger’s runtime footprint drops significantly when idle, demonstrating efficient resource reduction while maintaining enough background activity to ensure timely delivery of new messages and notifications without aggressive data usage.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Messenger (Background)}
    \label{tab:messenger_background_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 30.01 sec \\
        Total Events & 38,965 \\
        Events per Second & 1,298 \\
        Unique Processes & 175 \\
        Active Processes & 42 \\
        File Operations & 38,955 \\
        IPC Events & 0 \\
        Distinctive Patterns & 8 instances \\
        Read/Write Ratio & 1.50 \\
        Most Accessed File Type & .db (2,284 times) \\
        TCP Events & 8 \\
        UDP Events & 2 \\
        Total TCP Data & $<$ 0.01 MB \\
        UNIX Datagram Traffic & Not detected \\
        \hline
    \end{tabular}
\end{table}


\subsubsection{Signal Foreground Runtime Behaviour}

Signal demonstrates a notably lighter runtime signature compared to Messenger when operated under equivalent user-driven conditions.

Over an active usage window of about 30 seconds, Signal generated a total of 423,442 recorded events, yielding an average throughput of approximately 14,600 events per second—considerably lower than Messenger’s event rate, underscoring Signal’s leaner process structure and restrained resource use. Table~\ref{tab:signal_key_stats} summarises the core runtime metrics, showing that fewer unique processes were spawned and active at runtime.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Signal}
    \label{tab:signal_key_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 29.02 sec \\
        Total Events & 423,442 \\
        Events per Second & 14,600 \\
        Unique Processes & 546 \\
        Active Processes & 123 \\
        File Operations & 332,144 \\
        IPC Events & 50,680 \\
        Distinctive Patterns & 8 instances \\
        Read/Write Ratio & 1.03 \\
        Most Accessed File Type & .db (3,248 times) \\
        \hline
    \end{tabular}
\end{table}

File I/O operations account for most of the trace, supported by moderate IPC exchanges. The few \textit{distinctive patterns} noted indicate rare spikes in activity—such as isolated processes performing unexpected batches of operations—which are not inherently harmful but can warrant closer review during forensic analysis.

Regarding network behaviour and system call proportions, Signal recorded 263 TCP events, transferring about 1.62 MB (0.12 MB sent, 1.49 MB received), and showed no UDP traffic. Interestingly, no UNIX datagram traffic was captured during this session, which may reflect either the app’s design to avoid local service sockets or a limitation of the tracing setup to fully detect certain IPC channels. This point is acknowledged as a measurement constraint and is discussed further in the limitations section. The \texttt{ioctl} category accounts for over half of all calls, with balanced shares for \texttt{binder}, \texttt{read}, and \texttt{write} operations, as summarised below.

\begin{table}[H]
    \centering
    \caption{Network and Event Category Breakdown for Signal}
    \label{tab:signal_network_category}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Network Metric} & \textbf{Value} \\
        \hline
        TCP Events & 263 \\
        UDP Events & 0 \\
        Total TCP Data & 1.62 MB (0.12 MB sent, 1.49 MB received) \\
        UNIX Datagram Traffic & Not detected \\
        Unique Protocols & 3 \\
        Unique Connections & 1 \\
        \hline
        \textbf{Event Category} & \textbf{Proportion} \\
        \hline
        ioctl & 54.4\% \\
        binder & 14.4\% \\
        read & 13.4\% \\
        write & 13.0\% \\
        network & 4.8\% \\
        \hline
    \end{tabular}
\end{table}

In summary, these results confirm that Signal’s runtime footprint remains significantly lower than Messenger’s, prioritising secure transmission and minimal local overhead. This behaviour aligns well with its privacy-focused design, complementing insights from static analysis.



\subsubsection{Signal Background Runtime Behaviour}

When Signal operates in the background, its runtime footprint remains minimal compared to its active usage, which is logical and expected for a security-focused application designed to suppress unnecessary background processing. Over an observation window of approximately 29.5 seconds, a total of 30,663 events were recorded, corresponding to an average throughput of about 1,039 events per second—highlighting a substantial drop in runtime intensity relative to the foreground session.

The system call distribution shows a very high read-to-write ratio of 168.09, indicating that almost all operations consist of reading pre-existing local state, verifying data integrity, or performing lightweight consistency checks without actively writing back to storage. This behaviour demonstrates how Signal prioritises passive checks (such as validating message status or verifying session keys) while strictly avoiding unnecessary file modifications, aligning with its minimal data retention and privacy-first design.

File operations remain the dominant activity, while network communication is practically absent: only 5 TCP events were observed, with no UDP or other local socket activity detected. Inter-process communication was similarly inactive during this idle window, confirming that Signal's background logic does not rely on frequent module chaining or service calls.

Compared to Messenger’s background trace, Signal's passive footprint is significantly lower in all categories—fewer active processes, drastically fewer network requests, and a clear emphasis on read-only local checks. These observations, summarised in Table~\ref{tab:signal_background_key_stats}, reinforce Signal’s commitment to minimising persistent background presence and reducing potential metadata exposure.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Signal (Background)}
    \label{tab:signal_background_key_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 29.5 sec \\
        Total Events & 30,663 \\
        Events per Second & 1,039 \\
        Unique Processes & 134 \\
        Active Processes & 36 \\
        File Operations & 30,658 \\
        IPC Events & 0 \\
        Distinctive Patterns & 8 instances \\
        Read/Write Ratio & 168.09 \\
        Most Accessed File Type & .db (2,264 times) \\
        TCP Events & 5 \\
        UDP Events & 0 \\
        Total TCP Data & 0.02 MB (0.00 MB sent, 0.02 MB received) \\
        UNIX Datagram Traffic & Not detected \\
        \hline
    \end{tabular}
\end{table}


\subsubsection{Telegram Foreground Runtime Behaviour}

Telegram shows a noticeably heavier runtime profile than Signal and a closer footprint to Messenger when used under typical user-driven conditions. The test session included sending messages, recording a short voice note, and capturing an image to ensure realistic, feature-rich interaction.

Across an active usage window of approximately 30 seconds, Telegram generated a total of 549,824 recorded events, resulting in an average throughput of about 18,625 events per second. This high rate, summarised in Table~\ref{tab:telegram_key_stats}, indicates an application architecture optimised for rapid background operations and parallel handling of media-rich content.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Telegram}
    \label{tab:telegram_key_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 29.52 sec \\
        Total Events & 549,824 \\
        Events per Second & 18,625 \\
        Unique Processes & 789 \\
        Active Processes & 238 \\
        File Operations & 460,164 \\
        IPC Events & 47,629 \\
        Distinctive Patterns & 28 instances \\
        Read/Write Ratio & 1.39 \\
        Most Accessed File Type & .db (5,302 times) \\
        \hline
    \end{tabular}
\end{table}

File I/O is again dominant, with a slight bias towards read operations. IPC activity was substantial at 47,629 events, and 28 \textit{distinctive patterns} were flagged—meaning isolated processes showed sudden spikes in operations that stand out from the main activity flow, but do not imply malicious behaviour on their own.

Network-wise, Telegram initiated 462 TCP events and 3 UDP packets, transferring a total of 574.36 MB over TCP, of which 0.26 MB was sent and 574.10 MB was received. However, the unusually high inbound network traffic—574.10 MB received during a short interaction window—most likely results from a framework-related logging artefact or misattribution bug, rather than genuine application behaviour. As such, it will not be further analysed in the subsequent evaluation, but is noted here for completeness.
The absence of UNIX datagram traffic may again reflect either the app’s internal design or a limitation in the capture configuration. This large inbound traffic likely results from automatic media downloads, large attachment fetching, or possibly a background update triggered during the test window—an aspect noted for discussion in the limitations section. Event type proportions show that \texttt{ioctl} calls remain dominant (57.3\%), with read, write, and binder operations distributed evenly below that threshold.

\begin{table}[H]
    \centering
    \caption{Network and Event Category Breakdown for Telegram}
    \label{tab:telegram_network_category}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Network Metric} & \textbf{Value} \\
        \hline
        TCP Events & 462 \\
        UDP Events & 3 \\
        Total TCP Data & 574.36 MB (0.26 MB sent, 574.10 MB received)\textsuperscript{*} \\
        UNIX Datagram Traffic & Not detected \\
        Unique Protocols & 4 \\
        Unique Connections & 5 \\
        \hline
        \textbf{Event Category} & \textbf{Proportion} \\
        \hline
        ioctl & 57.3\% \\
        read & 16.8\% \\
        write & 12.1\% \\
        binder & 10.1\% \\
        network & 3.7\% \\
        \hline
    \end{tabular}
\begin{flushleft}
\scriptsize\textsuperscript{*} This unusually high inbound value is likely a logging artefact and is excluded from further analysis.
\end{flushleft}
\end{table}

Taken together, these results indicate that Telegram exhibits a consistently high I/O and inter-process communication (IPC) footprint, likely reflecting its architecture’s emphasis on media-rich interactions and continuous background synchronization.
\subsubsection{Telegram Background Runtime Behaviour}

When left running passively in the background, Telegram retains a moderately active runtime footprint, as expected. Over an observation window of approximately 30 seconds, the background session produced 39,340 total events, translating to about 1,318 events per second—representing roughly a 93\% reduction compared to its active throughput.

File operations dominate the trace, with 39,336 I/O events and a balanced read/write ratio of 1.45. Local database files (\texttt{.db}) remained the primary storage target, accessed 2,043 times, which reflects background cache refreshes or silent content syncing.

No inter-process communication was detected, contrasting with Telegram’s interactive use where IPC is more pronounced. Six distinctive patterns were flagged—brief spikes or repetitive calls that deviate slightly from the baseline but do not indicate suspicious behaviour.

Network usage stayed minimal: only 4 TCP events were logged and no UDP activity, with negligible data transferred ($<$ 0.02 MB), suggesting occasional keep-alive connections or push checks.

Overall, as summarised in Table~\ref{tab:telegram_background_stats}, Telegram’s background activity is more persistent than Signal’s near-silent idle mode but broadly similar to Messenger’s residual maintenance footprint.

\begin{table}[H]
    \centering
    \caption{Key Runtime Statistics for Telegram (Background)}
    \label{tab:telegram_background_stats}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Metric} & \textbf{Value} \\
        \hline
        Duration & 29.83 sec \\
        Total Events & 39,340 \\
        Events per Second & 1,318 \\
        Unique Processes & 194 \\
        Active Processes & 42 \\
        File Operations & 39,336 \\
        IPC Events & 0 \\
        Distinctive Patterns & 6 \\
        Read/Write Ratio & 1.45 \\
        Most Accessed File Type & .db (2,043 times) \\
        TCP Events & 4 \\
        UDP Events & 0 \\
        Total TCP Data & $\approx$ 0.02 MB \\
        \hline
    \end{tabular}
\end{table}


\subsubsection{Cross-Application Comparison}

When comparing the three applications under identical high-activity foreground scenarios, clear behavioural differences emerge. Messenger exhibits the highest overall file operations and IPC activity, reflecting its more complex interaction flows and heavier reliance on local data handling during messaging and multimedia tasks. Signal, in contrast, maintains the smallest runtime footprint in both I/O and network usage, aligning with its minimalistic and privacy-oriented architecture. Telegram also demonstrates elevated file and IPC activity, consistent with its emphasis on background synchronization and preloading mechanisms.

While the recorded network throughput for Telegram exceeded $570$ MB in a single session, this value is likely the result of a framework-level artefact and is therefore excluded from comparative conclusions. Nonetheless, previous analyses suggest that Telegram tends to prefetch media content and synchronise message history more aggressively than its counterparts, a pattern still observable through non-network signals.

Category distributions further confirm that while all three applications are dominated by \texttt{ioctl} and file operations, Telegram and Messenger maintain a more balanced proportion of \texttt{binder} and network calls, highlighting richer IPC layers and more frequent background exchanges than Signal.

Overall, this cross-app comparison underscores distinct architectural choices: Messenger favours constant local activity for performance and feature richness; Signal minimises runtime footprints to maximise privacy guarantees; and Telegram invests heavily in preloading and synchronization for a seamless content experience. These findings align consistently across both foreground and background measurements—excluding anomalous network values—and support the descriptive and statistical conclusions presented in the previous sections.

\begin{table}[H]
    \centering
    \caption{Comparison of Key Runtime Metrics Across Applications (Full Foreground Scenario)}
    \label{tab:comparison_key_metrics}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Metric} & \textbf{Messenger} & \textbf{Signal} & \textbf{Telegram} \\
        \hline
        Duration (sec) & 30.13 & 29.02 & 29.52 \\
        Total Events & 557,770 & 423,442 & 549,824 \\
        Events per Second & 4,628.72 & 14,600 & 7,607.57 \\
        Unique Processes & 1,184 & 546 & 789 \\
        Active Processes & 218 & 123 & 238 \\
        File Operations & 410,707 & 332,144 & 460,164 \\
        IPC Events & 85,836 & 50,680 & 47,629 \\
        Suspicious Patterns & 27 & 8 & 28 \\
        Read/Write Ratio & 1.73 & 1.03 & 1.39 \\
        Most Accessed File Type & .db (7,693) & .db (3,248) & .db (5,302) \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \caption{Comparison of Network Metrics and Event Category Distribution}
    \label{tab:comparison_network_categories}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Metric} & \textbf{Messenger} & \textbf{Signal} & \textbf{Telegram} \\
        \hline
        TCP Events & 750 & 263 & 462 \\
        UDP Events & 2 & 0 & 3 \\
        Total TCP Data & 3.48 MB & 1.62 MB & 574.36 MB \\
        UNIX Traffic & 2.44 MB sent / 48.2 MB received & None & None \\
        Unique Protocols & 4 & 3 & 4 \\
        Unique Connections & 2 & 1 & 5 \\
        \hline
        ioctl (\%) & 46.6 & 54.4 & 57.3 \\
        binder (\%) & 18.5 & 14.4 & 10.1 \\
        read (\%) & 18.1 & 13.4 & 16.8 \\
        write (\%) & 10.5 & 13.0 & 12.1 \\
        network (\%) & 6.3 & 4.8 & 3.7 \\
        \hline
    \end{tabular}%
    }
\end{table}

When comparing runtime behaviour in the passive background state, a more nuanced picture emerges. Signal demonstrates the most discreet background profile, dropping to near-zero network and IPC activity and performing only lightweight file reads for integrity checks. Messenger shows a moderate background footprint: while its event rate and active processes drop drastically compared to active use, it maintains background file I/O and minimal network pings, likely for push notifications and state synchronisation. Telegram remains the most active in the background among the three: although its event throughput decreases by over 90\% relative to its foreground mode, it sustains the highest residual file activity and some low-level network interactions, reflecting its design for persistent cache refresh and background synchronisation.

This comparison, summarised in Table~\ref{tab:comparison_bg_only}, confirms that while all three apps reduce processing when idle, Signal aligns most closely with privacy-by-design principles by minimising passive runtime footprint, whereas Telegram trades off background stealth for faster media availability and immediate message sync.

\begin{table}[H]
    \centering
    \caption{Background Scenario Comparison Across Applications}
    \label{tab:comparison_bg_only}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Metric} & \textbf{Messenger (BG)} & \textbf{Signal (BG)} & \textbf{Telegram (BG)} \\
        \hline
        Duration (sec) & 30.39 & 29.5 & 29.83 \\
        Total Events & 38,965 & 30,663 & 39,340 \\
        Events per Second & 1,283 & 1,039 & 1,318 \\
        File Operations & 38,955 & 30,658 & 39,336 \\
        IPC Events & 0 & 0 & 0 \\
        TCP Events & 8 & 5 & 4 \\
        Total TCP Data & $<$0.01 MB & 0.02 MB & 0.02 MB \\
        Distinctive Patterns & 8 & 8 & 6 \\
        Read/Write Ratio & 1.50 & 168.09 & 1.45 \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \footnotesize
    \caption{Foreground vs Background Comparison for Each Application}
    \label{tab:comparison_fg_vs_bg}
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Metric} & \textbf{Messenger (FG/BG)} & \textbf{Signal (FG/BG)} & \textbf{Telegram (FG/BG)} \\
        \hline
        Total Events & 557,770 / 38,965 & 423,442 / 30,663 & 549,824 / 39,340 \\
        Events per Second & 18,512 / 1,283 & 14,600 / 1,039 & 18,625 / 1,318 \\
        File Operations & 410,707 / 38,955 & 332,144 / 30,658 & 460,164 / 39,336 \\
        IPC Events & 85,836 / 0 & 50,680 / 0 & 47,629 / 0 \\
        TCP Events & 750 / 8 & 263 / 5 & 462 / 4 \\
        Total TCP Data & 3.48 MB / $<$0.01 MB & 1.62 MB / 0.02 MB & 574.36 MB\textsuperscript{*} / 0.02 MB \\
        Read/Write Ratio & 1.73 / 1.50 & 1.03 / 168.09 & 1.39 / 1.45 \\
        \hline
    \end{tabular}
    \begin{flushleft}
    \footnotesize\textsuperscript{*} Likely artefact; see Section "Telegram Foreground Runtime Behaviour".
    \end{flushleft}
\end{table}


Together, these updated measurements clearly illustrate how each messaging app adjusts its resource footprint between active user interaction and passive idle states — a crucial aspect that directly impacts privacy preservation, battery life, and perceived responsiveness.

\subsection{Cross-Application Comparative Analysis}

To advance beyond descriptive statistics, we conducted a one-way Analysis of Variance (ANOVA) to compare the means of multiple independent groups and test whether the observed differences in application behavior are statistically significant. This section outlines the methodology, assumptions, and post-hoc analyses, providing robust evidence for distinct architectural characteristics supported by inferential testing.

\subsubsection{Theoretical Background of ANOVA and Post-Hoc Testing}
The validity of ANOVA results hinges on three key assumptions, which were tested prior to analysis:
\begin{enumerate}[label=\roman*.]
    \item \textbf{Normality of Residuals:} The residuals (the differences between individual observations and their group mean) for each group must be normally distributed. This ensures the sampling distribution of the mean is reliable. For an observation \( Y_{ij} \) in group \(i\), the errors \( \varepsilon_{ij} = Y_{ij} - \mu_i \) should follow a normal distribution:
    $$ \varepsilon_{ij} \sim \mathcal{N}(0, \sigma^2) $$
    \item \textbf{Homogeneity of Variances (Homoscedasticity):} The variance within each group being compared must be equal. This is formally stated by the null hypothesis:
    $$ H_0: \sigma^2_1 = \sigma^2_2 = \dots = \sigma^2_k $$
    \item \textbf{Independence of Observations:} The observations in each group, as well as between groups, must be independent of one another.
\end{enumerate}


ANOVA tests the following null and alternative hypotheses concerning the population means \( \mu_i \) of the \( k \) application groups:
\begin{enumerate}[label=\roman*.]
    \item \textbf{Null Hypothesis ($H_0$):} All group means are equal, implying no difference in the measured metric across applications.
    $$ H_0: \mu_1 = \mu_2 = \dots = \mu_k $$
    \item \textbf{Alternative Hypothesis ($H_1$):} At least one group mean is different, indicating a significant effect of the application choice on the metric.
    $$ H_1: \exists i, j \text{ such that } \mu_i \neq \mu_j $$
\end{enumerate}
The F-statistic is calculated as the ratio of the variance between the groups ($MS_B$) to the variance within the groups ($MS_W$). A large F-value suggests that the variability between groups is high compared to the variability within groups.
$$
F = \frac{MS_B}{MS_W}, \quad \text{where} \quad MS_B = \frac{\sum_{i=1}^k n_i (\bar{Y}_i - \bar{Y})^2}{k-1} \quad \text{,} \quad MS_W = \frac{\sum_{i=1}^k \sum_{j=1}^{n_i} (Y_{ij} - \bar{Y}_i)^2}{N - k}
$$


A statistically significant ANOVA result (i.e., rejecting $H_0$) indicates that a difference exists, but does not specify which groups differ. To identify these specific pairwise differences, we employ a post-hoc test. We selected Tukey's Honestly Significant Difference (HSD) test because it is designed to control the family-wise error rate when performing all possible pairwise comparisons. The HSD critical value is calculated as:
$$
HSD = q_{\alpha, k, N-k} \sqrt{\frac{MS_W}{n}}
$$
where \( q \) is the value from the studentized range distribution for a given significance level \( \alpha \).

\subsubsection{Results of Statistical Tests}

To ensure the statistical robustness of our analysis and account for performance variability, we conducted 10 independent test runs for each application under controlled conditions. This iterative data collection process yields a more reliable and representative sample, minimizing the influence of anomalous executions or transient system states. We then applied our statistical methodology to three key performance metrics, calculated from the aggregated data of these 10 runs, to accurately profile each application's typical operational behavior.
\paragraph{(i) Events per Second:}
This metric measures the rate of system-level activity generated by an application, providing an indication of its overall operational intensity or "chattiness." It is calculated by dividing the total number of monitored system events (e.g., system calls, file access, etc.) by the duration of the measurement period in seconds:
$$
R_{\text{Events/sec}} = \frac{\sum N_{\text{Monitored Events}}}{T_{\text{execution (in seconds)}}}
$$
A higher value suggests a "busier" application with more frequent background processing or system interaction.

The assumptions of normality and homogeneity of variances were verified, confirming the data's suitability for ANOVA. Specifically, Shapiro-Wilk tests for each application were non-significant (Messenger: $p=0.1628$; Signal: $p=0.2032$; Telegram: $p=0.4871$), as was the Levene's test for equal variances ($p=0.3892$).

The subsequent ANOVA yielded a statistically significant result ($F(2, N-3) = 9.5461, p = 0.0033$). This indicates a clear difference in the rate of background event generation among the applications. The Tukey HSD post-hoc analysis provided a detailed breakdown:
\begin{itemize}
    \item \textit{Messenger vs. Signal:} A statistically significant difference was found ($p=0.0034$).
    \item \textit{Signal vs. Telegram:} A statistically significant difference was found ($p=0.0199$).
    \item \textit{Messenger vs. Telegram:} The difference was \textbf{not} statistically significant ($p=0.5923$).
\end{itemize}


\textbf{Interpretation:} This result statistically confirms that Signal operates with a significantly lower level of background activity. This aligns with its design philosophy of being a lightweight, resource-conscious application that minimizes its footprint.

\paragraph{(ii) Inter-Process Communication (IPC) Ratio:}
This metric quantifies the proportion of an application's internal communication overhead relative to its total system-level activity. It is calculated by dividing the number of IPC-related system calls (e.g., `binder`, `socketpair`, `pipe`) by the total number of events monitored:
$$R_{\text{IPC}} = \frac{\sum N_{\text{IPC Events}}}{\sum N_{\text{Total System Events}}}$$
A high value for this ratio indicates that a significant fraction of the application's work is dedicated to communication between its distinct components, which is characteristic of a modular or multi-process architecture.

For this metric, the normality assumption was violated for the Messenger application. Therefore, the ANOVA results should be interpreted with caution. Nonetheless, the test produced an extremely strong F-statistic ($F(2, N-3) = 35.6129, p < 0.001$). The subsequent Tukey HSD test indicated that \textbf{all pairwise comparisons} were highly significant.

\textbf{Interpretation:} Messenger's exceptionally high IPC ratio strongly suggests a complex, modular architecture. This design relies heavily on communication between distinct processes or services to manage its rich feature set, a common architectural pattern in large-scale, mature applications.

\paragraph{(iii) Network-to-File Ratio:}
This ratio directly compares an application's network data dependency against its reliance on local file storage. It is calculated as the ratio of total bytes transferred over network sockets to the total bytes read from and written to the local filesystem:
$$R_{\text{Net/File}} = \frac{\sum B_{\text{Network I/O}}}{\sum B_{\text{File I/O}}}$$
This metric effectively reveals an application's core operational strategy. A high ratio ($\gg 1$) signifies a "cloud-native" design that streams data on-demand, whereas a low ratio ($\ll 1$) points to an architecture that relies heavily on local caching and offline data access.

All ANOVA assumptions were satisfied for this metric. The analysis revealed a highly significant difference among the applications ($F(2, N-3) = 19.9452, p = 0.0002$). The Tukey HSD test clarified that Messenger's ratio is significantly different from both Signal and Telegram, while the latter two are not significantly different from each other on this metric.

\textbf{Interpretation:} Telegram's distinctively high ratio points to a cloud-native architectural model. The application is optimized for high-volume network data transfers (e.g., fetching media and extensive chat histories from the cloud) relative to its local file I/O operations, clearly distinguishing its operational strategy from the other applications.

\subsubsection{Conclusive Synthesis and Interpretation}

The collective results of these statistical tests provide quantitative, verifiable proof of the architectural trade-offs inherent in each application's design. The analysis moves beyond simple observation to confirm the following data-driven profiles:
\begin{itemize}
    \item \textbf{Messenger} is characterized as a feature-rich, complex ecosystem that leverages a high degree of Inter-Process Communication to orchestrate its many functionalities.
    \item \textbf{Signal} is statistically verified as a resource-efficient application, deliberately engineered to minimize its background footprint by generating significantly fewer system events.
    \item \textbf{Telegram} exhibits a cloud-centric architecture, prioritizing high-throughput network operations to deliver a seamless, cloud-synchronized user experience, setting it apart from more device-centric models.
\end{itemize}
These findings successfully align with our thesis goals, providing a robust statistical foundation for understanding the different design philosophies and performance footprints of these widely-used messaging applications. A summary of the p-values is provided in Table~\ref{tab:comparative_tests_en}.

\begin{table}[H]
\centering
\caption{Summary of ANOVA Test Results and p-values}
\label{tab:comparative_tests_en}
\begin{tabular}{lc}
\toprule
\textbf{Performance Metric} & \textbf{p-value} \\
\midrule
Events per Second & 0.0033 \\
IPC Ratio & $< 0.001$ (cautionary) \\
Network-to-File Ratio & 0.0002 \\
\bottomrule
\end{tabular}
\end{table}


\subsection{Behavioural Patterns Observed}

\subsubsection{Messenger Full Foreground Scenario}

The Messenger application, when running with full permissions in the foreground, shows an event pattern typical of messaging clients during active usage. As illustrated in the \textit{Event Timeline} (Figure~\ref{fig:messenger-full-events}), the \texttt{write} and \texttt{ioctl} system calls occur in parallel over a substantial portion of the session, followed by a continuous sequence of \texttt{read} operations. Throughout the timeline, \texttt{network} activity appears more scattered and intermittent.

This arrangement likely reflects how the application first writes data and performs control operations to manage outgoing content or system resources, then maintains an extended reading phase to handle incoming data streams and message updates. The dispersed network events suggest periodic syncs or background connections rather than a constant data flow.

Overall, this event distribution is representative of real-time messaging behaviour and will be seen in a similar form across different scenarios and applications, highlighting that such patterns stem from the nature of messaging workflows rather than any single app-specific implementation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{messenger-full-events.png}
    \caption{Event Timeline of Messenger in Full Foreground Scenario.}
    \label{fig:messenger-full-events}
\end{figure}

The \textit{Behavior Timeline} (Figure~\ref{fig:messenger-full-behav}) distinctly highlights Messenger’s interaction with user contacts, a behaviour that is largely absent in Signal and only marginally present in Telegram. Here, repeated contact lookups and metadata synchronisations are evident alongside simultaneous camera and audio usage. This confirms Messenger’s extensive data integration to support features such as rich chat, stories, and contact suggestions.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{messenger-full-behav.png}
    \caption{Behavior Timeline of Messenger in Full Foreground Scenario.}
    \label{fig:messenger-full-behav}
\end{figure}

The \textit{Communication Flow} diagram (Figure~\ref{fig:messenger-full-flow}) reinforces the app’s architectural complexity: a dense cluster of process IDs branches out from a central dispatcher, with multiple nodes playing a pivotal role in handling high-frequency tasks. Compared to Signal’s and Telegram’s flows, Messenger maintains more worker PIDs actively participating in both foreground and background operations, highlighting its design to manage simultaneous media, chat, and backend connectivity with minimal latency.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{messenger-full-flow.png}
    \caption{Communication Flow of Messenger in Full Foreground Scenario.}
    \label{fig:messenger-full-flow}
\end{figure}

Overall, these patterns confirm that Messenger leverages full device permissions not only for multimedia but also for dynamic access to contacts and advanced inter-process orchestration. This expansive behavioural footprint, while supporting richer features, simultaneously broadens the attack surface, which should be considered in any security and privacy evaluation.


\subsubsection{Messenger Restricted Permissions Scenario}
While most applications behaved as expected when permissions were restricted, the analysis of Messenger under these conditions revealed a significant anomaly. Due to its critical nature, this behavior is examined in detail in Section~\ref{sec:messenger_anomaly}.

\subsubsection{Signal Full Foreground Scenario}

When running with full permissions, Signal shows similar patterns to other clients.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{signal-full-events.png}
    \caption{Event Timeline of Signal in Full Foreground Scenario.}
    \label{fig:signal-full-events}
\end{figure}

The \textit{Behavior Timeline} (Figure~\ref{fig:signal-full-behav}) shows consistent camera and microphone use, with TCP connections appearing mostly towards the end of the session for message transmission. Unlike Messenger, no contacts access is observed.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{signal-full-behav.png}
    \caption{Behavior Timeline of Signal in Full Foreground Scenario.}
    \label{fig:signal-full-behav}
\end{figure}

The \textit{Communication Flow} (Figure~\ref{fig:signal-full-flow}) depicts a simple IPC graph with a few worker PIDs, reflecting minimal process spawning and strict sandboxing.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{signal-full-flow.png}
    \caption{Communication Flow of Signal in Full Foreground Scenario.}
    \label{fig:signal-full-flow}
\end{figure}

Overall, these results confirm Signal’s design priorities: essential media capture and encrypted transport, with no unnecessary data or contact access.

\subsubsection{Signal Restricted Permissions Scenario}

When Signal runs with restricted permissions, its runtime behaviour remains simple and predictable. The \textit{Event Timeline} (Figure~\ref{fig:signal-none-events}) shows the same general pattern as in full mode: \texttt{write} and \texttt{ioctl} calls occur together initially, followed by a continuous \texttt{read} phase, and scattered \texttt{network} events.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{signal-none-events.png}
    \caption{Event Timeline of Signal in Restricted Permissions Scenario.}
    \label{fig:signal-none-events}
\end{figure}

The \textit{Behavior Timeline} (Figure~\ref{fig:signal-none-behav}) confirms minimal behaviour: only a few TCP events appear, with no access to contacts, camera, or microphone, which fully aligns with the restricted permissions granted in this scenario.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{signal-none-behav.png}
    \caption{Behavior Timeline of Signal in Restricted Permissions Scenario.}
    \label{fig:signal-none-behav}
\end{figure}

Finally, the \textit{Communication Flow} (Figure~\ref{fig:signal-none-flow}) shows an extremely lightweight process graph with just a single child PID, reflecting Signal’s strict process isolation and minimal background activity.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{signal-none-flow.png}
    \caption{Communication Flow of Signal in Restricted Permissions Scenario.}
    \label{fig:signal-none-flow}
\end{figure}

In summary, Signal stays consistent with its design: even under restricted permissions, no sensitive data like contacts is accessed, and only basic network connections are maintained.



\subsubsection{Telegram Full Foreground Scenario}

When running in full foreground mode, Telegram shows a typical high-activity pattern.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{telegram-full-events.png}
    \caption{Event Timeline of Telegram in Full Foreground Scenario.}
    \label{fig:telegram-full-events}
\end{figure}

The \textit{Behavior Timeline} (Figure~\ref{fig:telegram-full-behav}) shows frequent camera and microphone use, stable TCP connections, and clear contact access near the end, indicating background syncing alongside media messaging.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{telegram-full-behav.png}
    \caption{Behavior Timeline of Telegram in Full Foreground Scenario.}
    \label{fig:telegram-full-behav}
\end{figure}

The \textit{Communication Flow} (Figure~\ref{fig:telegram-full-flow}) shows a multi-worker structure similar to Messenger, though slightly less intricate, enabling parallel processing of messages, media, and sync routines.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{telegram-full-flow.png}
    \caption{Communication Flow of Telegram in Full Foreground Scenario.}
    \label{fig:telegram-full-flow}
\end{figure}

Overall, Telegram behaves much like Messenger, offering rich media and contact syncing, but with a slightly simpler and lighter runtime footprint compared to Messenger.

\subsubsection{Telegram Restricted Permissions Scenario}

When Telegram runs with restricted permissions the \textit{Event Timeline} (Figure~\ref{fig:telegram-none-events}) shows the same general structure as other clients: \texttt{write} and \texttt{ioctl} appear first, followed by continuous \texttt{read} and scattered \texttt{network} calls — but all with lower density due to disabled features.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{telegram-none-events.png}
    \caption{Event Timeline of Telegram in Restricted Permissions Scenario.}
    \label{fig:telegram-none-events}
\end{figure}

The \textit{Behavior Timeline} (Figure~\ref{fig:telegram-none-behav}) confirms minimal behaviour: only a few TCP events are recorded, while camera, microphone, and contacts remain inactive — fully consistent with the blocked permissions.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{telegram-none-behav.png}
    \caption{Behavior Timeline of Telegram in Restricted Permissions Scenario.}
    \label{fig:telegram-none-behav}
\end{figure}

The \textit{Communication Flow} (Figure~\ref{fig:telegram-none-flow}) reveals a simple process tree with very few worker PIDs, showing that background media and sync threads are inactive under permission constraints.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{telegram-none-flow.png}
    \caption{Communication Flow of Telegram in Restricted Permissions Scenario.}
    \label{fig:telegram-none-flow}
\end{figure}

Overall, Telegram adapts correctly to restricted permissions by falling back to basic network checks only, avoiding sensitive access and unnecessary processing.

\subsection{Persistent Contact Access in Messenger}
\label{sec:messenger_anomaly}
The analysis of the Messenger application, under conditions of explicitly denied permissions, revealed a potential privacy bypass that highlights an area for improvement within the Android permission model. Despite the user revoking contacts permission through the standard Android interface, systematic access to the contacts database persisted. This access was achieved through an indirect but consistently reproducible mechanism.

When executed with restricted permissions, Messenger exhibited extensive contacts database access that appeared to contradict the configured settings. As shown in Figure~\ref{fig:messenger-none-events}, while the overall event timeline appears conventional, kernel-level analysis of a 30.35-second trace identified systematic read/write operations on the \texttt{contacts2.db} database and its associated temporary files (\texttt{-shm}, \texttt{-wal}). The Behavior Timeline in Figure~\ref{fig:messenger-none-behav} quantifies this, revealing over 100 distinct database operations. This pattern was not incidental, appearing consistently across nine out of ten test runs.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{messenger-none-events.png}
    \caption{Event Timeline of Messenger showing unexpected database activity despite restricted permissions.}
    \label{fig:messenger-none-events}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{messenger-none-behav.png}
    \caption{Behavior Timeline quantifying persistent contacts database operations (100+ events) during the trace period.}
    \label{fig:messenger-none-behav}
\end{figure}
Further investigation through detailed Binder Inter-Process Communication (IPC) analysis revealed that the contacts access does not originate directly from the Messenger application itself. Instead, it stems from a Content Provider process (PID 27488, UID 10064) activated by a Binder worker thread. Listing~\ref{lst:binder-trace} provides a representative excerpt from the kernel trace illustrating this indirect access to \texttt{contacts2.db}.

\clearpage
\begin{lstlisting}[language=bash, caption={Kernel trace showing contacts database access via a Binder worker thread.}, label={lst:binder-trace}]
binder:27488_B-7197 (27488) [000] d..1. 116474.302632: ioctl_probe: (do_vfs_ioctl) file=... pathname="contacts2.db"
binder:27488_B-7197 (27488) [000] d..1. 116474.302693: read_probe: (vfs_read) file=... buf=... count=100 pathname="contacts2.db"
binder:27488_B-7197 (27488) [000] d..1. 116474.303025: read_probe: (vfs_read) file=... count=4096 pathname="contacts2.db"
\end{lstlisting}

This indirect access constitutes a three-stage bypass of the Android permission model, involving Messenger, Google Play Services, and the Android Content Provider. This process is illustrated in Figure~\ref{fig:messenger-indirect-flow}.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=1.5cm and 2.5cm,
        font=\sffamily\small,
        box/.style={rectangle, draw, thick, rounded corners=3pt, fill=#1, text width=3cm, align=center, minimum height=1.5cm, drop shadow={opacity=0.3}},
        app/.style={box=blue!15},
        service/.style={box=green!20},
        provider/.style={box=red!15},
        db/.style={
            cylinder, shape border rotate=90, draw, thick, minimum height=1.5cm, minimum width=2.2cm, aspect=0.4,
            cylinder uses custom fill, cylinder body fill=gray!30, cylinder end fill=gray!10,
            align=center, text width=2cm, drop shadow={opacity=0.3}
        },
        arrow/.style={-Latex, thick},
        denied/.style={-Latex, thick, red, densely dashed},
        allowed/.style={-Latex, thick, green!70!black}
    ]

    % Nodes
    \node[app] (messenger) {\textbf{Messenger App} \\ (PID 20660) \\ {\footnotesize\color{red!80!black}Contacts: DENIED}};
    \node[service, right=of messenger] (gms) {\textbf{Google Play Services} \\ (PID 29281) \\ {\footnotesize\color{green!60!black}System Privileges}};
    \node[provider, below=of gms] (provider) {\textbf{Content Provider} \\ (PID 27488) \\ {\footnotesize\color{green!60!black}System Access}};
    \node[db, below=of provider] (db) {\scriptsize\texttt{contacts2.db}};


    % Direct access path (blocked)
    \draw[denied] (messenger) to[bend right=60] node[midway, below, sloped] {Direct Access Blocked} (db);

    % Indirect access path (the exploit)
    \path[allowed]
        (messenger) edge node[above, align=center, text width=2.5cm] {1. API Calls \\ \texttt{\tiny(CombinedTP)}} (gms)
        (gms)       edge node[right] {2. SyncAdapter Trigger} (provider)
        (provider)  edge node[right] {3. DB Operations} (db);

    \end{tikzpicture}
    \caption{Information flow diagram illustrating how Messenger bypasses denied permissions by using Google Play Services' SyncAdapter as a proxy to access the contacts database.}
    \label{fig:messenger-indirect-flow}
\end{figure}

The stages of this bypass are detailed below:

\begin{lstlisting}[language=bash, caption={Stage 1: Messenger to Google Play Services.}, label={lst:stage1-bypass}]
# Stage 1: Messenger (PID 20660) -> Google Play Services (PID 29281)
CombinedTP27-20885   ( 20660) ... binder_transaction: transaction=6750378 dest_proc=29281 ...
\end{lstlisting}

\begin{lstlisting}[language=bash, caption={Stage 2: Google Play Services to Content Provider.}, label={lst:stage2-bypass}]
# Stage 2: GMS (29281) -> Content Provider (27488)
SyncAdapterThre-20959 ( 29281) ... binder_transaction: transaction=6754221 dest_proc=27488 ...
\end{lstlisting}

\begin{lstlisting}[language=bash, caption={Stage 3: Content Provider to contacts database.}, label={lst:stage3-bypass}]
# Stage 3: Content Provider (27488) -> contacts2.db
binder:27488_B-7197 ( 27488) ... read_probe: ... pathname="contacts2.db"
\end{lstlisting}

This information flow was corroborated by automated tools, such as Slicedroid, which confirmed the communication between the three implicated processes.


The core of this vulnerability lies in a \textbf{persistent sync adapter state} that survives permission revocation. The timeline below, also illustrated in Figure~\ref{fig:sync-persistence}, explains this critical flaw:

\begin{enumerate}
    \item \textbf{Grant:} A user initially grants Messenger contacts permission.
    \item \textbf{Register:} The app registers a sync task with Google Play Services, creating a persistent entry in the Android AccountManager.
    \item \textbf{Revoke:} The user later revokes the permission via Settings.
    \item \textbf{Persist:} The sync adapter registration is \textbf{not cleared} and remains active.
    \item \textbf{Trigger:} When Messenger runs, it makes generic API calls to Google Play Services, which in turn triggers the persistent sync adapter, leading to unauthorized contacts access via a privileged system service.
\end{enumerate}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        box/.style={
            rectangle, rounded corners=3pt,
            draw=black!65, very thick,
            fill=gray!20,
            text width=6cm, align=center,
            minimum height=1.2cm
        },
        arrow/.style={
            -{Latex[length=3mm,width=2mm]},
            thick
        },
        node distance=1.2cm
    ]

    % Vertical Timeline states
    \node[box] (grant) {\textbf{1. Permission Granted} \\ Sync adapter is registered.};
    \node[box, below=of grant] (revoke) {\textbf{2. Permission Revoked} \\ User revokes permission in Settings.};
    \node[box, below=of revoke] (persist) {\textbf{3. State Persists} \\ Sync registration is NOT cleared.};
    \node[box, below=of persist] (access) {\textbf{4. Access Continues} \\ App triggers sync via GMS proxy.};

    % Vertical Arrows
    \path[arrow]
        (grant) edge (revoke)
        (revoke) edge (persist)
        (persist) edge (access);

    \node[
        fit=(revoke) (persist) (access),
        draw=red!80!black,
        very thick,
        dashed,
        rounded corners,
        inner sep=8pt,
        label={[text=red!80!black, font=\sffamily\bfseries]right:DESIGN ASPECT TO CONSIDER}
    ] (flaw_box) {};

    \end{tikzpicture}
    \caption{Timeline showing the core vulnerability: the sync adapter’s state persists beyond permission revocation, creating a permanent access channel.}
    \label{fig:sync-persistence}
\end{figure}


Interestingly, when Messenger is granted contacts permission, the access pattern to the contacts database differs significantly. In such cases, Messenger directly accesses the data via the standard Android ContentProvider interface, using an internal worker thread (e.g., Worker-2), as shown in Listing~\ref{lst:stage3-granted-permission}.

\begin{lstlisting}[language=bash, caption={Contacts Database Access via Content Provider with Granted Permission.}, label={lst:stage3-granted-permission}]
Worker-2-29606 ( 28473) [000] d..1. 55456.666750: read_probe: (vfs_read+0x0/0x488) file=0xffffff815e3c8280 buf=0x7ca89f71e0 count=0x64 inode=4483 k__dev=0 s_dev_inode=266338357 i_mode=33200 kuid=10064 kgid=10064 pathname="contacts2.db"
\end{lstlisting}

This contrast underscores that the observed bypass mechanism is not the default behavior but rather an evasive strategy triggered specifically when direct access is denied. The anomalous behavior persists only when the user has revoked the permission, highlighting the exploitation of privileged system components.

This potential vulnerability has significant privacy implications, as it creates a "control illusion" where users believe their actions have secured their data, when, in reality, access may continue unabated. Our findings suggest a gap in Android's permission architecture: the model appears incomplete, as it may not fully manage the lifecycle of persistent states, such as sync registrations, upon permission changes. This could allow privileged system services to be unknowingly leveraged as privacy bypasses, potentially undermining the foundation of informed consent in the mobile ecosystem.

While this study focused on the Messenger application, further research would be beneficial to confirm the broader extent of this issue across other applications utilizing similar Google Play Services sync patterns.

\chapter{Discussion}

\section{Interpretation of Results}

The combined static and dynamic analyses yield a nuanced understanding of the architectural and operational trade-offs embodied by \textit{Signal}, \textit{Telegram}, and \textit{Messenger}. Our findings confirm the central hypothesis: that each application's security posture and runtime behaviour are direct reflections of its underlying design principles. This aligns with broader research demonstrating that an app's privacy implications are deeply rooted in its architecture and choice of third-party libraries~\cite{ShenVervierStringhini2021}.

From a static perspective, Signal’s lean manifest configuration and restrictive permission set correspond with its security-first design, a finding consistent with formal analyses of its protocol that highlight its cryptographic robustness~\cite{CohnGordon2017SignalAnalysis}. In contrast, Messenger exhibits the broadest architectural footprint, featuring an extensive inventory of components and third-party telemetry SDKs. This observation corroborates large-scale studies by Shen et al., who identified Facebook's infrastructure as a central hub for data collection via embedded trackers~\cite{ShenVervierStringhini2021}. Telegram's architecture presents a middle ground; while free of third-party trackers, its allowance of clear-text HTTP traffic and extensive permissions align with forensic studies that have noted its hybrid security model, which prioritises features like cloud synchronisation over default end-to-end encryption~\cite{moltchanov2018telegram}.

Dynamic tracing validates these static insights by providing empirical evidence of runtime behaviour. The finding that Messenger generates the highest event throughput and most intensive inter-process communication is consistent with its complex, feature-rich design. Signal's minimal runtime footprint reinforces its characterisation as a privacy-preserving application, while Telegram's high network-to-file ratio underscores its cloud-native architecture.

A critical finding appears to be that Messenger accesses the contacts2.db database even when its permission is denied. This could exemplify a critical "permission gap" in Android. Our kernel-level analysis seemed to trace an indirect information flow: Messenger initiate an API call to Google Play Services, which in turn could trigger a persistent SyncAdapter that accesses the contacts Content Provider with system-level privileges. This suggests an interaction that potentially bypasses the user-facing permission model.

Finally, the statistically significant differences in event rates and resource usage patterns between the applications, confirmed by ANOVA and Tukey HSD tests, provide quantitative validation for these qualitative distinctions. While other studies have performed forensic analyses of these apps at rest~\cite{anglano2015whatsapp, obermeier2018signal}, our work contributes by delivering a comparative analysis of their live system behaviour, demonstrating that architectural philosophies translate into measurable, kernel-level operational fingerprints.

\section{Answers to Research Questions}

\paragraph{\textbf{RQ1.} What systematic methodology can be used for a comparative security and privacy analysis of mobile messaging applications?}

This study demonstrates that a robust comparative methodology should integrate static analysis (using tools such as \textsc{MobSF}, \textsc{APKID}, and \textsc{Androguard}) with dynamic kernel-level tracing. Static inspection reveals manifest configurations, declared permissions, and embedded secrets, while dynamic tracing uncovers real runtime behaviour, including syscall patterns, inter-process communication, and actual network usage. Together, these methods provide a replicable, data-driven framework for assessing mobile application privacy and security.

\paragraph{\textbf{RQ2.} Is static analysis alone sufficient to uncover privacy-intrusive behaviour, or do kernel-level traces reveal additional hidden operations and syscall patterns?}

The results suggest that static analysis alone may not be sufficient to uncover the full range of privacy-relevant behaviours. Kernel-level traces exposed runtime activity that appears inconsistent with manifest-level declarations — for instance, Messenger seemed to interact with contacts-related resources even when permissions were explicitly restricted. While this observation does not conclusively prove unauthorized access, it highlights behaviours that are not visible through static inspection alone. Additionally, dynamic analysis uncovered characteristics such as background synchronization and large-scale media prefetching, which would remain undetected by static tools. Therefore, the combination of static and dynamic methods provides a more comprehensive understanding of potential privacy risks.

\paragraph{\textbf{RQ3.} Which system calls do popular messaging apps issue during normal use, and how do these calls align with—or diverge from—their declared permissions?}

The analysis confirms that all three applications rely heavily on standard system calls such as \texttt{ioctl}, \texttt{read}, \texttt{write}, and \texttt{binder} for routine operation. Generally, the syscall usage aligns with the permissions declared in their manifests. However, dynamic traces exposed cases where behaviour diverged: Messenger's continued contact access under restricted permissions illustrates a gap between static declarations and runtime execution, highlighting the value of tracing for verifying real adherence to permission models.

\paragraph{\textbf{RQ4.} How do privacy-centric apps (e.g., Signal) compare to mainstream platforms in terms of data minimisation, syscall footprint, and overall privacy posture?}

Signal exhibits the leanest runtime signature, the lowest event throughput, and the smallest network footprint among the three apps, all of which validate its privacy-first architecture. In contrast, Messenger shows high inter-process complexity and extensive local data operations, supporting its feature-rich functionality but broadening its attack surface. Telegram emphasises a network-heavy design, evident in its high network-to-file ratio and large data transfers, which enable fast media delivery but increase dependency on secure cloud infrastructure. These statistically validated profiles demonstrate distinct trade-offs between feature richness and privacy preservation.

In summary, this thesis confirms that static and dynamic analyses, combined with inferential statistical validation, provide a robust, replicable basis for assessing the security and privacy posture of mobile messaging applications in practice.

\section{Opportunities for Improvement}

Many of the opportunities for future enhancement directly address the methodological and project-specific constraints outlined in Section~1.4. This thesis demonstrates the value of combining static and dynamic analysis, but several areas remain for significant enhancement. The primary opportunity lies in expanding the experimental scope. Future work should conduct a large-scale analysis across a more diverse set of applications from various categories~\cite{lindorfer2014andrubis} and extend the trace duration from seconds to minutes or even hours. Such a longitudinal approach would capture subtle background and idle-state behaviors often missed in short-term observations~\cite{Razaghpanah2020AppsTrackers}. This would also allow for profiling more complex user interaction scenarios (e.g., group video calls, large file transfers) that could expose different system behaviours and protocol usage, such as UDP. Notably, further examination of the \texttt{contacts2.db} access by Messenger—possibly via dynamic taint analysis~\cite{enck2014taintdroid}—could determine whether this is due to indirect IPC or a platform-level oversight.

On the tooling side, integrating deeper network-layer visibility would enhance behavioral reconstruction. Beyond capturing packet data with \texttt{tcpdump}~\cite{lindorfer2014andrubis}, this could include DNS query analysis to identify server endpoints and inspection of TLS handshake metadata (e.g., Server Name Indication - SNI), which reveals communication endpoints even through encrypted traffic~\cite{apthorpe2018smart}. Furthermore, improving trace labelling automation to reconstruct API semantics from syscalls~\cite{nisi2019syscall} and expanding the analysis to include pre-installed system apps~\cite{Tian2020Preinstalled} would offer a more holistic perspective on mobile device behaviour.


% --------------------------------------------------
%  Conclusions
% --------------------------------------------------
\chapter{Conclusions}

\section{Key Findings}
This thesis set out to systematically assess the security and privacy posture of three widely used mobile messaging applications—Signal, Telegram, and Messenger—by combining rigorous static configuration inspection with low-level kernel-based dynamic tracing. The findings confirm that each application embodies distinct architectural trade-offs that manifest clearly in both static risk factors and runtime system behaviour. Static analysis revealed that Signal consistently maintains the leanest manifest and permission configuration, with minimal exported components and no bundled trackers, aligning closely with its privacy-first design philosophy. In contrast, Messenger exhibits the largest architectural footprint, with a complex component graph, broad permission set, and inclusion of third-party telemetry SDKs, reflecting a design optimised for feature richness at the expense of a larger attack surface. Telegram situates itself between these extremes: it avoids trackers but adopts a more permissive network configuration and permits clear-text traffic.

Dynamic tracing validated and extended these insights by quantifying actual system call patterns under controlled usage scenarios. Signal demonstrated the smallest event throughput and background footprint, confirming its resource-conscious approach. Messenger generated the highest volume of inter-process communication and file I/O, evidencing a rich but complex orchestration of services. Telegram displayed a network-dominant profile, with a significantly higher network-to-file ratio, indicating its cloud-native strategy for fast media synchronisation. Inferential statistical tests confirmed that these differences are not incidental but statistically significant, lending robust support to the core research questions. In summary, the combined analysis illustrates that while all three applications meet baseline security expectations, their operational behaviours differ in ways that directly reflect their respective design priorities, impacting user privacy and resource consumption.

Among the most conclusive findings was the discovery of a persistent privacy violation by Messenger, which continues to access contact-related resources even after its permission is explicitly revoked. Our analysis provides strong indications that this occurs due to a persistent sync adapter state maintained by Google Play Services, which acts as a proxy. The precise origin of this access, appears to be potentially attributed to a design characteristic in the Android permission model, where revoking a permission might not clear associated sync states, possibly creating an unacknowledged data access channel.

\section{Future Work}

The methodological framework established in this thesis opens several avenues for future research, moving beyond the immediate technical details to address broader questions of digital privacy and security.

A primary next step is to apply this combined analytical approach to a wider and more diverse range of mobile applications. While this study focused on messaging apps, the methodology could yield significant insights into other domains where user data is sensitive, such as banking, healthcare (mHealth), or social media applications. Such a large-scale study would help establish a broader baseline for ”normal” versus ”suspicious” behaviour across the mobile ecosystem and could reveal systemic privacy risks tied to specific app categories or development practices.

Furthermore, future work should investigate the long-term behaviour of applications. The current analysis captured short, controlled user interactions. Extending the observation period to hours or even days would allow for a more comprehensive understanding of an app’s lifecycle, particularly its idle-state and background activities. This longitudinal analysis could uncover subtle, periodic data collection or communication patterns that are invisible during brief tests but are critical to an application’s overall privacy footprint.

Finally, a crucial direction is to conclusively identify the source of privacy-anomalous behaviours, such as Messenger’s access to the contacts database. While this study provided strong evidence of the behaviour at the kernel level, the next logical step would be to employ more advanced techniques to trace the exact chain of events within the application that leads to this access. Answering such questions would not only solve a technical puzzle but also provide key insights into bypassing platform security models, helping developers and vendors build more secure systems.

% --------------------------------------------------
%  Βibliography
% --------------------------------------------------
\begin{thebibliography}{99}

% --- Academic Papers & Foundational Works ---
\bibitem{apthorpe2018smart}
N. Apthorpe, D. Reisman, and N. Feamster, “A Smart Home is No Castle: Privacy Vulnerabilities of Encrypted IoT Traffic,” \emph{arXiv preprint arXiv:1705.06805}, 2017.

\bibitem{arp2014drebin}
D. Arp, M. Spreitzenbarth, M. Hübner, H. Gascon, and K. Rieck, “Drebin: Effective and explainable detection of Android malware in your pocket,” in \emph{Proc. NDSS '14}, 2014.

\bibitem{arzt2014flowdroid}
S. Arzt \emph{et al.}, “FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps,” in \emph{Proc. PLDI '14}, 2014.

\bibitem{berezowski2020push}
T. Berezowski, “Push-IM: Leakage in Mobile Instant Messaging Push Notifications,” in \emph{Proc. ACSAC WIP '20}, 2020.

\bibitem{bock2020sealed}
J. Bock \emph{et al.}, “A Formal Analysis of Signal's Sealed Sender,” in \emph{Proc. IEEE EuroS\&P '21}, 2021.

\bibitem{BPFroid2021}
N. Agman, M. Marcelli, and M. Conti, “BPFroid: A Robust Real-Time Android Malware Detection Framework,” in \emph{Proc. IEEE ARES ’21}, Vienna, Austria, Aug. 2021.

\bibitem{candroid2019}
L. Xu, G. Li, C. Li, W. Sun, Z. Li, and J. zhang, “Condroid: A Container-Based Virtualization Solution Adapted for Android Devices,” in \emph{Proc. IEEE MobileCloud '15}, 2015.

\bibitem{celik2021stego}
L. Caviglione, W. Mazurczyk, M. Repetto, A. Schaffhauser, and M. Zuppelli, “Kernel-level tracing for detecting stegomalware and covert channels in Linux environments,” \emph{Computer Networks}, vol. 191, 2021.

\bibitem{CHI2024Permissions}
S.~J. Oishwee, Z.~Codabux, and N.~Stakhanova, “Decoding Android Permissions: A Study of Developer Challenges and Solutions on Stack Overflow,” in \emph{Proc. 18th ACM/IEEE Int. Symp. on Empirical Software Engineering and Measurement (ESEM ’24)}, Barcelona, Spain, Oct. 2024, pp. 143–153, doi:10.1145/3674805.3686676.

\bibitem{CohnGordon2017SignalAnalysis}
K. Cohn-Gordon, C. Cremers, B. Dowling, L. Garratt, and D. Stebila, “A Formal Security Analysis of the Signal Messaging Protocol,” \emph{Extended Version, Available Online}, July 2019.

\bibitem{dynamo2021}
H. González \emph{et al.}, “DYNAMO: Differential dynamic analysis of the Android framework,” in \emph{Proc. NDSS '21}, 2021.

\bibitem{dynalog2016}
M. K. Alzaylaee, S. Y. Yerima, and S. Sezer, “Dynalog: an automated dynamic analysis framework for characterizing android applications,” in \emph{Proc. 2016 Int. Conf. on Cyber Security and Protection of Digital Services (Cyber Security)}, 2016.

\bibitem{DynamicSecurityAnalysis2023}
T. Sutter, T. Kehrer, M. Rennhard, B. Tellenbach, and J. Klein, “Dynamic Security Analysis on Android: A Systematic Literature Review,” \emph{IEEE Access}, vol. 12, pp. 9234-9262, 2024. [Online]. Available: \url{https://doi.org/10.1109/ACCESS.2024.3357593}

\bibitem{egele2019cdn}
M. R. May, K. V. Valo, A. G. Lurie, S. P. G. T. Gunja, and M. Egele, “Persistence of Deleted Media in Telegram CDNs,” in \emph{Proc. IMC '19}, 2019.

\bibitem{lu2012chex}
L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, “CHEX: Statically vetting Android apps for component hijacking vulnerabilities,” in \emph{Proc. of the 19th ACM conference on Computer and communications security (CCS '12)}, 2012, pp. 260-271.

\bibitem{enck2014taintdroid}
W. Enck \emph{et al.}, “TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones,” \emph{ACM Transactions on Computer Systems (TOCS)}, vol. 32, no. 2, article 5, 2014.

\bibitem{felt2011androidprivacy}
A. P. Felt \emph{et al.}, “Android Permissions Demystified,” in \emph{Proc. 18th ACM Conference on Computer and Communications Security (CCS)}, 2011.

\bibitem{feng2020survey}
Z. Feng \emph{et al.}, “A Survey on Security and Privacy Issues in Android,” \emph{IEEE Communications Surveys \& Tutorials}, vol. 22, no. 4, pp. 2445–2472, 2020.

\bibitem{frolov2022gdpr}
S. Frolov, E. Mark, and D. L. Dittrich, “GDPR Compliance in Mobile Messaging Apps,” in \emph{Proc. PETS '22}, 2022.

\bibitem{inviseal2023}
K. Papadopoulos \emph{et al.}, “InviSeal: Stealthy instrumentation for Android,” in \emph{Proc. AsiaCCS '23}, 2023.

\bibitem{kwon2021telegram}
D. Kwon, “Triangulating Telegram Users via ‘People Nearby’,” in \emph{Proc. IEEE S\&P '21}, 2021.

\bibitem{lee2023quic}
H. Lee, S. Lee, H. Kim, and S. J. oh, “QUIC-based Traffic Fingerprinting of Messaging Apps,” in \emph{Proc. TMA '23}, 2023.

\bibitem{li2015iccta}
L. Li, A. Bartel, T. F. Bissyandé, J. Klein \emph{et al.}, “IccTA: Detecting inter-component privacy leaks in Android apps,” in \emph{Proc. ICSE ’15}, 2015.

\bibitem{li2016droidra}
L. Li, T. F. Bissyandé, D. Octeau, and J. Klein, “DroidRA: Taming reflection to support whole-program analysis of Android apps,” in \emph{Proc. ISSTA '16}, 2016.

\bibitem{libdroid2022}
S. Li, Z. Qian, and F. Zhang, “LibDroid: Summarizing information flow of Android native libraries via static analysis,” \emph{Digital Investigation}, vol. 40, 2022.

\bibitem{lindorfer2014andrubis}
M. Lindorfer \emph{et al.}, “ANDRUBIS - 1,000,000 Apps Later: A View on Current Android Malware Behaviors,” in \emph{Proc. BADGERS '14}, 2014.

\bibitem{marforio2022psi}
C. Marforio, “SGX Side-Channels on Private Set Intersection,” in \emph{Proc. ASIACCS '22}, 2022.

\bibitem{matic2015iMessage}
S. Matic \emph{et al.}, “iMessage Privacy,” in \emph{Proc. USENIX Security '15}, 2015.

\bibitem{arxiv2020metadata}
P. Manoharan, A. Panchenko, and T. Engel, “An Empirical Study of Metadata Leakage in Secure Messaging Services,” \emph{arXiv preprint arXiv:2002.04609}, 2020.

\bibitem{moltchanov2018telegram}
A. Moltchanov \emph{et al.}, “Telegram—A Forensic View,” in \emph{Proc. DFRWS EU '18}, 2018.

\bibitem{nasser2023dlamdet}
A. R. Nasser, A. M. Hasan, and A. J. Humaidi, “DL-AMDet: Deep learning-based malware detector for Android,” \emph{Intelligent Systems with Applications}, vol. 21, 2024.

\bibitem{ning2019dexlego}
Z. Ning and F. Zhang, “DexLEGO: Reassembleable bytecode extraction for aiding static analysis,” in \emph{Proc. DSN '18}, 2018.

\bibitem{nisi2019syscall}
S. Nisi \emph{et al.}, “Reconstructing API semantics from syscall traces on Android,” in \emph{Proc. RAID '19}, 2019.

\bibitem{obermeier2018signal}
S. Obermeier and S. Diederich, “Signal forensics on Android devices,” \emph{Journal of Digital Forensics, Security and Law}, vol. 13, no. 2, 2018.

\bibitem{octeau2013epicc}
D. Octeau, P. McDaniel, S. Jha \emph{et al.}, “Effective inter-component communication mapping in Android with Epicc,” in \emph{Proc. USENIX Security '13}, 2013.

\bibitem{poblete2021defence}
J. Poblete, “Adaptive Padding against IM Traffic Analysis,” \emph{Computer Communications}, vol. 178, pp. 104-113, 2021.

\bibitem{Razaghpanah2020AppsTrackers}
A. Razaghpanah, R. Nithyanand, N. Vallina-Rodriguez, S. Sundaresan, M. Allman, C. Kreibich, and P. Gill, “Apps, Trackers, Privacy, and Regulators: A Global Study of the Mobile Tracking Ecosystem,” in \emph{Proc. of the IEEE Symposium on Security and Privacy (S\&P)}, 2018.

\bibitem{Schmidt2009IDSyscall}
A. Schmidt, H. Schmidt, J. Clausen, A. M. T. K. Camtepe, and S. Albayrak, “Static analysis of executables for collaborative malware detection on Android,” in \emph{Proc. of the IEEE International Conference on Communications (ICC)}, 2009.

\bibitem{ShenVervierStringhini2021}
Y. Shen, P.-A. Vervier, and G. Stringhini, ``Understanding worldwide private information collection on Android,'' \emph{arXiv preprint arXiv:2102.12869}, 2021.

\bibitem{SLR2025Messaging}
A. R. Onik, J. Brown, C. Walker, and I. Baggili, “A Systematic Literature Review of Secure Instant Messaging Applications from a Digital Forensics Perspective,” \emph{ACM Computing Surveys}, vol. 57, no. 9, Article 239, pp. 1–36, May 2025. [Online]. Available: \url{https://doi.org/10.1145/3727641}

\bibitem{tang2020whatsappHash}
P. Tang, “Hash-Based Enumeration Attack on WhatsApp Contact Discovery,” in \emph{Proc. CCS '20}, 2020.

\bibitem{anglano2015whatsapp}
C. Anglano, ``Forensic Analysis of WhatsApp Messenger on Android Smartphones,'' \emph{arXiv preprint arXiv:1507.07739}, 2015.

\bibitem{Tian2020Preinstalled}
J. Gamba, M. Rashed, A. Razaghpanah, J. Tapiador, and N. Vallina-Rodriguez, “An Analysis of Pre-installed Android Software,” in \emph{Proc. of the IEEE Symposium on Security and Privacy (S\&P)}, 2020.

\bibitem{wei2014amandroid}
F. Wei, S. Roy, X. Ou, and Robby, “Amandroid: A precise and general inter-component data-flow analysis framework for security vetting of Android apps,” in \emph{Proc. CCS '14}, 2014.

\bibitem{williams2024emook}
D. Williams \emph{et al.}, “eMook: Eliminating eBPF Tracing Overhead on Untraced Processes,” in \emph{Proc. eBPF‘24 Workshop}, 2024.

\bibitem{zhang2020hart}
F. Zhang \emph{et al.}, “HART: Hardware-Assisted Kernel Module Tracing on ARM,” in \emph{Proc. ESORICS '20}, 2020.

\bibitem{zheng2014droidtrace}
M. Zheng and M. Sun, “DroidTrace: Ptrace-based dynamic syscall tracing for Android,” \emph{International Journal of Information Security}, vol. 13, no. 4, pp. 359-370, 2014.

% --- News, Reports & White Papers ---
\bibitem{ArsTechnica2018}
S. Gallagher, “Facebook scraped call, text message data for years from Android phones,” \emph{Ars Technica}, Mar. 2018. [Online]. Available: \url{https://arstechnica.com/information-technology/2018/03/facebook-scraped-call-text-message-data-for-years-from-android-phones/}

\bibitem{Backlinko2025}
B. Dean, “WhatsApp User Statistics 2025: How Many People Use WhatsApp?,” Backlinko, Feb. 2025. [Online]. Available: \url{https://backlinko.com/whatsapp-users}

\bibitem{DataReportal2025}
DataReportal, “Digital 2025: Global Digital Overview – mobile‐phone users reach 5.81 billion,” Apr. 2025. [Online]. Available: \url{https://datareportal.com/global-digital-overview}

\bibitem{maganti2022perfetto}
L. Maganti, “Analyzing Perfetto Traces at Every Scale,” in \emph{Tracing Summit}, 2022.

\bibitem{Politico2025Signal}
E. Golden, “Inside the hazy, fractured mess of Signal use in the government,” \emph{POLITICO}, Apr. 2025. [Online]. Available: \url{https://www.politico.com/news/2025/04/02/inside-the-hazy-fractured-mess-of-signal-chats-in-the-government-00264466}

\bibitem{qbdiblackhat2020}
R. Thomas, “QBDI and DBI on ARM,” in \emph{BlackHat Asia}, 2020.

\bibitem{Reuters2021WhatsAppExodus}
M. S. Sibal and N. S. Roshni, “Signal, Telegram see demand spike as new WhatsApp terms stir debate,” \emph{Reuters}, Jan. 2021. [Online]. Available: \url{https://www.reuters.com/article/idUSKBN29E04O/}

\bibitem{signalwhitepaper}
Signal Foundation, \emph{Signal Protocol White Paper}, 2023. [Online]. Available: \url{https://signal.org/docs/specifications/signal-protocol/}

\bibitem{StatCounter2025}
StatCounter Global Stats, “Mobile Operating System Market Share Worldwide – April 2025,” 2025. [Online]. Available: \url{https://gs.statcounter.com/os-market-share/mobile/worldwide}

\bibitem{StatistaMessenger}
Statista, “Leading mobile messaging apps worldwide as of June 2024, by number of monthly active users,” 2024. [Online]. Available: \url{https://www.statista.com/statistics/258749/most-popular-global-mobile-messenger-apps/}

\bibitem{statista2024smartphone}
Statista, \emph{Number of smartphone users worldwide from 2014 to 2029}, 2024. [Online]. Available: \url{https://www.statista.com/forecasts/1143723/smartphone-users-in-the-world}

\bibitem{StatistaSignal}
Statista, “Signal - monthly active users in selected countries 2021,” 2022. [Online]. Available: \url{https://www.statista.com/statistics/1252396/signal-monthly-active-users-in-selected-countries/}

\bibitem{StatistaTelegram}
Statista, “Number of Telegram monthly active users worldwide from 2018 to 2024,” 2024. [Online]. Available: \url{https://www.statista.com/statistics/1242337/telegram-users/}

\bibitem{washingtonpost2023signal}
The Washington Post, “Pentagon officials used Signal messaging app, raising security concerns,” Mar. 2023.

\bibitem{wired2023signalhack}
A. Greenberg, “How a Signal Knockoff Used by the US Military Got Hacked in 20 Minutes,” \emph{WIRED}, Aug. 2023. [Online]. Available: \url{https://www.wired.com/story/how-the-signal-knock-off-app-telemessage-got-hacked-in-20-minutes/}

% --- Software, Tools & Frameworks ---
\bibitem{androguard2023}
A. Desnos and contributors, “Androguard: Reverse engineering and analysis of Android applications,” 2023. [Online]. Available: \url{https://github.com/androguard/androguard}

\bibitem{ebpf2023}
eBPF Foundation, “eBPF: Extended Berkeley Packet Filter,” 2023. [Online]. Available: \url{https://ebpf.io}

\bibitem{frida2020}
Frida Project, \emph{Frida: Dynamic Instrumentation Toolkit—White Paper}, 2020.

\bibitem{jadx}
skylot, “Jadx: Dex to Java decompiler,” [Online]. Available: \url{https://github.com/skylot/jadx}

\bibitem{mobsf2023}
A. Abraham, “Mobile Security Framework (MobSF),” 2023. [Online]. Available: \url{https://github.com/MobSF/Mobile-Security-Framework-MobSF}

\bibitem{strace2023}
The strace developers, “strace: Diagnostic, debugging and instructional userspace utility for Linux,” 2023. [Online]. Available: \url{https://strace.io}

\bibitem{xposed}
rovo89, “Xposed Framework,” [Online]. Available: \url{https://github.com/rovo89/Xposed}

% --- Books & Official Documentation ---
\bibitem{AOSP2024Ftrace}
Android Open Source Project, “Use ftrace,” Oct. 2024. [Online]. Available: \url{https://source.android.com/docs/core/tests/debug/ftrace}

\bibitem{AOSPArchOverview}
Android Open Source Project, “Platform Architecture,” 2024. [Online]. Available: \url{https://source.android.com/docs/core/architecture}

\bibitem{AOSPART}
Android Open Source Project, “Android Runtime (ART) and Dalvik,” 2024. [Online]. Available: \url{https://source.android.com/docs/core/dalvik}

\bibitem{AOSPGKI}
Android Open Source Project, “Generic Kernel Image (GKI),” 2024. [Online]. Available: \url{https://source.android.com/docs/core/gki}

\bibitem{AOSPJNI}
Android Open Source Project, “JNI tips,” 2024. [Online]. Available: \url{https://developer.android.com/training/articles/perf-jni}

\bibitem{AOSPSecurity}
Android Open Source Project, “Android Security Overview,” 2024. [Online]. Available: \url{https://source.android.com/docs/security/overview/android}

\bibitem{AOSPWakelocks}
Android Open Source Project, “PowerManager.WakeLock,” 2024. [Online]. Available: \url{https://developer.android.com/reference/android/os/PowerManager.WakeLock}

\bibitem{debugfs}
The Linux Kernel, “debugfs,” The Linux Kernel Documentation. [Online]. Available: \url{https://www.kernel.org/doc/html/latest/filesystems/debugfs.html}

\bibitem{ftrace2023}
S. Rostedt, “ftrace: The Linux Kernel Function Tracer,” The Linux Kernel Documentation, 2023. [Online]. Available: \url{https://www.kernel.org/doc/html/latest/trace/ftrace.html}

\bibitem{kprobes2023}
The Linux Kernel, “Kernel Probes (Kprobes),” The Linux Kernel Documentation, 2023. [Online]. Available: \url{https://www.kernel.org/doc/html/latest/trace/kprobes.html}

\bibitem{love2010linux}
R. Love, \emph{Linux Kernel Development}, 3rd ed., Addison-Wesley, 2010.

\bibitem{tanenbaum2015modern}
A. S. Tanenbaum and H. Bos, \emph{Modern Operating Systems}, 4th ed., Pearson, 2015.

% --- Regulations & Legal Acts ---
\bibitem{GDPR2016}
European Parliament and Council, “Regulation (EU) 2016/679 (General Data Protection Regulation),” \emph{Official Journal of the European Union}, L119, May 2016.

\bibitem{UKDPA2018}
UK Parliament, \emph{Data Protection Act 2018}, c. 12, May 2018. [Online]. Available: \url{https://www.legislation.gov.uk/ukpga/2018/12/contents}

\end{thebibliography}

% --------------------------------------------------
%  Appendices
% --------------------------------------------------
\appendix

\chapter{Appendix: Code}
\label{appendix:app-mapper-code}

\section*{App Mapping Main Logic}

The following excerpt shows the core logic responsible for generating the app mapping by pulling APKs from a connected Android device and analyzing them to extract commercial names using \texttt{androguard}.



\begin{lstlisting}[language=Python]
def get_app_label(self, package_name: str) -> Optional[str]:
    if not ANDROGUARD_AVAILABLE:
        return None
    try:
        result = subprocess.run(["adb", "shell", "pm", "path", package_name],
                                capture_output=True, text=True, timeout=10)
        for line in result.stdout.splitlines():
            if line.startswith("package:"):
                device_apk_path = line.split(":", 1)[1].strip()
                break
        temp_apk = tempfile.NamedTemporaryFile(suffix=".apk", delete=False)
        subprocess.run(["adb", "pull", device_apk_path, temp_apk.name],
                       capture_output=True, text=True, timeout=30)
        apk = APK(temp_apk.name)
        return apk.get_app_name()
    except Exception:
        return None
    finally:
        if os.path.exists(temp_apk.name):
            os.unlink(temp_apk.name)
\end{lstlisting}


\newpage
\begin{lstlisting}[language=Python]
def create_mapping(self, limit: int = 30, include_system: bool = False) -> Dict[str, Dict]:
    mapping = {}
    installed_packages = self.get_installed_packages(user_apps_only=True)
    for package in installed_packages:
        name = self.get_app_label(package)
        if name:
            mapping[package] = {
                "package_name": package,
                "commercial_name": name,
                "processes": [package[-15:]],
                "is_running": True
            }
    return mapping
\end{lstlisting}

\end{document}
